<!-- Interaktive Julia-Menge Visualisierung -->
<!-- noUiSlider CDN -->
<link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css" rel="stylesheet" integrity="sha384-PSZaVsyG9jDu8hFaSJev5s/9poIJlX7cuxSGdqCgXRHpo2DzIaZAyCd2rG/DJJmV" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js" integrity="sha384-/gBUOLHADjY2rp6bHB0IyW9AC28q4OsnirJScje4l1crgYW7Qarx3dH8zcqcUgmy" crossorigin="anonymous"></script>
<!-- Tom Select CDN -->
<link href="https://cdn.jsdelivr.net/npm/tom-select@2.4.1/dist/css/tom-select.css" rel="stylesheet" integrity="sha384-ny89R1e2Q335kISzsNGnOmYXcpZzyhDAQHA4nPPBPWSlNj9MWD5KQLMtuGTX4z0X" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/tom-select@2.4.1/dist/js/tom-select.complete.min.js" integrity="sha384-U3YO9KA9gHoGO+Y5cTqEtWp5gy6hbXb3vfj0lvl+Zvt7OJLKVPf+5enfdivNC0td" crossorigin="anonymous"></script>

<div class="julia-container focus-mode" id="julia-container">
  <h2 class="julia-title">Interaktive Julia-Menge</h2>
  <div class="julia-toolbar">
    <button id="juliaFocusMode" class="toggle-button active" title="Fokusmodus" aria-label="Fokusmodus" aria-pressed="true">
      <span class="icon"><i class="fas fa-crosshairs" aria-hidden="true"></i></span>
      <span class="btn-text">Fokus</span>
    </button>
    <div class="toolbar-button-group">
      <button id="resetZoom" class="toggle-button" title="Zoom zurücksetzen" aria-label="Zoom zurücksetzen">
        <span class="icon"><i class="fas fa-undo" aria-hidden="true"></i></span>
        <span class="btn-text">Reset</span>
      </button>
      <button id="applySettings" class="toggle-button" title="Neu berechnen" aria-label="Neu berechnen">
        <span class="icon"><i class="fas fa-sync" aria-hidden="true"></i></span>
        <span class="btn-text">Neu</span>
      </button>
    </div>
    <button id="juliaFullscreen" class="toggle-button" title="Vollbild" aria-label="Vollbild">
      <span class="icon"><i class="fas fa-expand" aria-hidden="true"></i></span>
      <span class="btn-text">Vollbild</span>
    </button>
  </div>
  <div class="julia-controls">
    <div class="controls-basic">
      <div class="control-row">
        <label for="maxIterations">Iterationen:</label>
        <div id="maxIterationsSlider" class="nouislider-wrapper"></div>
        <span id="iterValue" class="value-chip">250</span>
      </div>
      <div class="color-intensity-group">
        <div class="color-control-item">
          <label>Farben:</label>
          <select id="colorScheme" class="form-control">
            <option value="blau-rot">Blau-Rot</option>
            <option value="cyberpunk">Cyberpunk</option>
            <option value="retrowave" selected>Retrowave</option>
            <option value="feuer">Feuer</option>
            <option value="ozean">Ozean</option>
            <option value="monochrom">Monochrom</option>
            <option value="regenbogen">Regenbogen</option>
            <option value="ultraviolett">Ultraviolett</option>
            <option value="goldgrün">Gold-Grün</option>
          </select>
        </div>
        <button id="colorIntensity" class="toggle-button intensity-toggle" title="Farbintensität umschalten" aria-label="Farbintensität">
          <span class="icon"><i class="fas fa-adjust" aria-hidden="true"></i></span>
          <span class="btn-text">Subtil</span>
        </button>
      </div>
      <!-- Erweitert-Button am Ende der Basic Controls -->
      <div class="advanced-toggle-row">
        <button id="juliaAdvancedToggle" class="toggle-button expand-toggle" title="Erweiterte Optionen anzeigen" aria-label="Erweiterte Optionen" aria-expanded="false">
          <span class="icon"><i class="fas fa-sliders-h" aria-hidden="true"></i></span>
          <span class="btn-text">Erweiterte Optionen</span>
          <span class="chevron"><i class="fas fa-chevron-down" aria-hidden="true"></i></span>
        </button>
      </div>
    </div>
    <div class="controls-advanced">
      <div class="control-row">
        <label for="realPart">c (Real):</label>
        <div id="realPartSlider" class="nouislider-wrapper"></div>
        <span id="realValue" class="value-chip">-0.7</span>
      </div>
      <div class="control-row">
        <label for="imagPart">c (Imag):</label>
        <div id="imagPartSlider" class="nouislider-wrapper"></div>
        <span id="imagValue" class="value-chip">0.27</span>
      </div>
      <!-- Preset-Dropdown für c-Werte -->
      <div class="preset-row">
        <label for="presetValues">Preset:</label>
        <select id="presetValues" class="preset-select">
          <option value="standard" data-real="-0.70" data-imag="0.27" selected>Standard (-0.70, 0.27)</option>
          <option value="seepferdchen" data-real="-0.78" data-imag="-0.11">Seepferdchen (-0.78, -0.11)</option>
          <option value="blitz" data-real="-0.835" data-imag="-0.2321">Blitz (-0.84, -0.23)</option>
          <option value="dendrit" data-real="0.285" data-imag="0.01">Dendrit (0.29, 0.01)</option>
        </select>
      </div>
      <!-- Kompakte Toggle-Zeile -->
      <div class="toggle-row">
        <button id="allowExtremeZoom" class="toggle-button compact" title="Extremzoom erlauben" aria-label="Extremzoom">
          <span class="icon"><i class="fas fa-bolt" aria-hidden="true"></i></span>
          <span class="btn-text">Extremzoom: Aus</span>
        </button>
        <button id="saveImage" class="toggle-button icon-only" title="Bild speichern" aria-label="Bild speichern">
          <span class="icon"><i class="fas fa-download" aria-hidden="true"></i></span>
        </button>
      </div>
    </div>
  </div>

  <div class="canvas-container">
    <div class="canvas-overlay">
      <div class="overlay-item">c: <span id="positionInfo">0 + 0i</span></div>
      <div class="overlay-item">Zoom: <span id="zoomInfo">1×</span></div>
    </div>
    <canvas id="juliaCanvas" width="960" height="540"></canvas>
    <div id="zoomBox" class="zoom-box"></div>
    <div class="loading-indicator" id="loadingIndicator">Berechne...</div>
    <div class="zoom-warning" id="zoomWarning">Extremzoom aktiv – Details koennen instabil sein.</div>
    
    <!-- Seitlicher Zoom-Regler für Smartphones -->
    <div class="mobile-zoom-control" id="juliaMobileZoom">
      <div class="zoom-buttons-container">
        <button class="zoom-button zoom-in" id="juliaZoomIn" aria-label="Julia vergrößern">+</button>
        <div class="zoom-level-display" id="juliaZoomLevel">1.00×</div>
        <button class="zoom-button zoom-out" id="juliaZoomOut" aria-label="Julia verkleinern">−</button>
      </div>
    </div>
    
  </div>
  
  <div class="explanation-container">
    <button id="toggleExplanation" class="explanation-toggle" aria-label="Erklärung ein-/ausblenden" aria-expanded="false" onclick="toggleExplanationBox(this)">Erklärung anzeigen <span style="font-size: 10px;">▼</span></button>
    <div id="explanationBox" class="explanation-box">
      <h3>Die Julia-Menge</h3>
      
      <section class="explanation-section">
        <h4>Was ist die Julia-Menge?</h4>
        <p>Die Julia-Menge ist ein <strong>Fraktal</strong> – ein Muster, das sich bei jeder Vergrößerung wiederholt, ähnlich wie Schneeflocken oder Küstenlinien in der Natur. Das Besondere: Egal wie tief du hineinzoomst, es tauchen immer wieder ähnliche Strukturen auf – das nennt man <em>Selbstähnlichkeit</em>.</p>
      </section>
      
      <section class="explanation-section">
        <h4>So funktioniert's</h4>
        <p>Stell dir vor, du nimmst jeden Punkt auf dem Bildschirm und wendest immer wieder dieselbe Rechenregel an: <code>zₙ₊₁ = zₙ² + c</code>. Manche Punkte bleiben dabei „gefangen" (sie werden nie größer als 2) – diese bilden die Julia-Menge und werden schwarz dargestellt.</p>
        <p>Alle anderen Punkte „entkommen" irgendwann ins Unendliche. Die <strong>Farbe</strong> zeigt, wie schnell ein Punkt entkommt – das ist die sogenannte <em>Fluchtgeschwindigkeit</em>.</p>
        <p class="hint">Der Parameter <code>c</code> ist eine Konstante aus zwei Zahlen (Real- und Imaginärteil). Jeder Wert von <code>c</code> erzeugt eine völlig andere Julia-Menge!</p>
      </section>
      
      <section class="explanation-section">
        <h4>Parameter</h4>
        
        <div class="param-group">
          <h5>Komplexe Konstante c</h5>
          <p>Real- und Imaginärteil definieren gemeinsam <code>c = Re + Im·i</code>. Probiere verschiedene Werte aus:</p>
          <ul>
            <li><strong>Re ∈ [-2, 0.25], Im ≈ 0</strong> — Zusammenhängende Strukturen</li>
            <li><strong>Re ≈ -0.75, Im ≈ 0.1</strong> — „Dendriten" mit baumartigen Verzweigungen</li>
            <li><strong>Re ≈ 0, Im ≈ 1</strong> — Kreisähnliche Muster</li>
            <li><strong>c außerhalb der Mandelbrot-Menge</strong> — Fragmentierte „Staub"-Strukturen</li>
          </ul>
          <p class="hint">Kleine Änderungen können dramatische Effekte haben – experimentiere!</p>
        </div>
        
        <div class="param-group">
          <h5>Maximale Iterationen</h5>
          <p>Bestimmt, wie oft die Rechenregel angewendet wird, bevor ein Punkt als „gefangen" gilt:</p>
          <ul>
            <li><strong>10–50</strong> — Schnell, weniger Details</li>
            <li><strong>100–200</strong> — Ausgewogen (empfohlen)</li>
            <li><strong>300+</strong> — Maximale Details, langsamer</li>
          </ul>
          <p class="hint">Bei tiefem Zoom brauchst du mehr Iterationen für scharfe Grenzen.</p>
        </div>
        
        <div class="param-group">
          <h5>Farbschema</h5>
          <p>Visualisiert die Fluchtgeschwindigkeit – wie schnell Punkte entkommen:</p>
          <div class="color-grid">
            <span class="color-tag">Blau-Rot</span>
            <span class="color-tag">Cyberpunk</span>
            <span class="color-tag">Retrowave</span>
            <span class="color-tag">Feuer</span>
            <span class="color-tag">Ozean</span>
            <span class="color-tag">Monochrom</span>
            <span class="color-tag">Regenbogen</span>
            <span class="color-tag">Ultraviolett</span>
            <span class="color-tag">Gold-Grün</span>
          </div>
        </div>
      </section>
      
      <section class="explanation-section">
        <h4>Navigation</h4>
        
        <div class="nav-columns">
          <div class="nav-column">
            <h5>Desktop</h5>
            <ul>
              <li><strong>Mausrad</strong> — Zoom an Position</li>
              <li><strong>Linksklick + Ziehen</strong> — Rechteck-Zoom</li>
              <li><strong>Rechtsklick + Ziehen</strong> — Verschieben</li>
              <li><strong>Leertaste + Ziehen</strong> — Verschieben</li>
              <li><strong>Doppelklick</strong> — Herauszoomen</li>
            </ul>
          </div>
          <div class="nav-column">
            <h5>Touch</h5>
            <ul>
              <li><strong>Pinch</strong> — Zoom hinein/heraus</li>
              <li><strong>1-Finger-Ziehen</strong> — Verschieben</li>
              <li><strong>+/− Buttons</strong> — Zoom-Steuerung</li>
            </ul>
          </div>
        </div>
        <p class="hint">Zoome tief hinein und entdecke die Selbstähnlichkeit – Strukturen wiederholen sich in immer kleineren Maßstäben!</p>
      </section>
      
      <section class="explanation-section">
        <h4>Mandelbrot-Verwandtschaft</h4>
        <p>Julia- und Mandelbrot-Menge sind eng verwandt: Punkte <em>innerhalb</em> der Mandelbrot-Menge erzeugen zusammenhängende Julia-Mengen, Punkte <em>außerhalb</em> erzeugen fragmentierten „Staub".</p>
      </section>
    </div>
  </div>
</div>

<style>
  .julia-container {
    display: flex;
    flex-direction: column;
    max-width: 100%;
    margin: 0 auto;
    background: #222;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  }
  
  .julia-title {
    color: #eacfb4;
    margin: 0 0 20px 0;
    padding: 10px 0;
    text-align: center;
    font-size: 24px;
    font-weight: 600;
    border-bottom: 2px solid #444;
    position: relative;
  }
  
  .julia-title::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 2px;
    background-color: #05d9e8;
  }
  
  /* ========================================
     Julia Controls Panel - Modern Compact Design
     ======================================== */
  .julia-controls {
    margin-bottom: 15px;
    background: linear-gradient(135deg, #2a2a2a 0%, #1e1e1e 100%);
    padding: 16px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .julia-toolbar {
    display: flex;
    gap: 8px;
    flex-wrap: nowrap;
    margin-bottom: 12px;
    justify-content: space-between;
  }

  .julia-toolbar .toggle-button {
    flex: 1;
    min-width: 0;
    max-width: 140px;
    justify-content: center;
  }

  .julia-toolbar .icon {
    margin-right: 6px;
  }

  /* ========================================
     Toolbar Button Group (Reset + Neu)
     ======================================== */
  .toolbar-button-group {
    display: flex;
    flex: 1;
    max-width: 140px;
    gap: 4px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    padding: 3px;
  }
  
  .toolbar-button-group .toggle-button {
    flex: 1;
    min-width: 0;
    max-width: none;
  }
  
  @media (max-width: 480px) {
    .toolbar-button-group .btn-text {
      display: none;
    }
    .toolbar-button-group .icon {
      margin-right: 0;
    }
  }

  /* ========================================
     Expand Toggle Button (Erweitert)
     ======================================== */
  .advanced-toggle-row {
    margin-top: 14px;
    padding-top: 14px;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
  }
  
  .expand-toggle {
    width: 100%;
    justify-content: center;
    gap: 8px;
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.02);
    border: 1px dashed rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 13px;
    transition: all 0.25s ease;
  }
  
  .expand-toggle:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(5, 217, 232, 0.3);
    color: rgba(255, 255, 255, 0.9);
  }
  
  .expand-toggle .chevron {
    display: flex;
    align-items: center;
    margin-left: auto;
    transition: transform 0.3s ease;
  }
  
  .expand-toggle .chevron i {
    font-size: 12px;
  }
  
  /* Active state when panel is open */
  .julia-container.advanced-open .expand-toggle {
    background: rgba(5, 217, 232, 0.1);
    border-color: rgba(5, 217, 232, 0.3);
    border-style: solid;
    color: #05d9e8;
    -webkit-box-shadow: 0 0 8px 2px rgba(5, 217, 232, 0.2);
    box-shadow: 0 0 8px 2px rgba(5, 217, 232, 0.2);
  }
  
  .julia-container.advanced-open .expand-toggle .chevron {
    transform: rotate(180deg);
  }

  .btn-text {
    white-space: nowrap;
  }

  /* Mobile: Vertikales Layout */
  .controls-basic,
  .controls-advanced {
    display: flex;
    flex-direction: column;
    gap: 14px;
  }

  .controls-advanced {
    display: none;
    margin-top: 14px;
    padding-top: 14px;
    border-top: 1px solid rgba(5, 217, 232, 0.2);
  }

  .julia-container.advanced-open .controls-advanced {
    display: flex;
  }

  /* Desktop: 2-Column Grid Layout */
  @media (min-width: 900px) {
    .controls-basic {
      display: grid !important;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
      gap: 14px;
      align-items: center;
    }
    
    /* Iterations-Slider links */
    .controls-basic > .control-row {
      grid-column: 1;
      grid-row: 1;
    }
    
    /* Farben-Dropdown + Intensität-Button rechts */
    .controls-basic > .color-intensity-group {
      grid-column: 2;
      grid-row: 1;
    }
    
    /* Erweitert-Button volle Breite */
    .controls-basic > .advanced-toggle-row {
      grid-column: 1 / -1;
      grid-row: 2;
    }
    
    /* Advanced Controls: 2-Spalten Grid */
    .controls-advanced {
      margin-top: 14px;
      padding-top: 14px;
      border-top: 1px solid rgba(5, 217, 232, 0.2);
    }
    
    .julia-container.advanced-open .controls-advanced {
      display: grid !important;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    
    .controls-advanced > .control-row:nth-child(1) {
      grid-column: 1;
      grid-row: 1;
    }
    
    .controls-advanced > .control-row:nth-child(2) {
      grid-column: 2;
      grid-row: 1;
    }
    
    /* Preset-Dropdown volle Breite */
    .controls-advanced > .preset-row {
      grid-column: 1 / -1;
      grid-row: 2;
      max-width: 100%; /* Prevent overflow */
    }
    
    /* Preset Dropdown-Breite auf Desktop begrenzen */
    .controls-advanced > .preset-row .ts-wrapper {
      max-width: 400px; /* Sinnvolle Maximalbreite für Dropdown */
    }
    
    /* Toggle-Zeile volle Breite */
    .controls-advanced > .toggle-row {
      grid-column: 1 / -1;
      grid-row: 3;
    }
  }

  .julia-container.focus-mode {
    padding: 10px;
  }

  .julia-container.focus-mode .julia-controls {
    display: none;
  }

  /* explanation-container bleibt immer sichtbar, auch im focus-mode */

  .julia-container.focus-mode .canvas-overlay {
    display: flex;
  }

  .julia-container.fullscreen-mode .canvas-overlay {
    display: flex;
  }

  .julia-container.fullscreen-mode.focus-mode .canvas-overlay {
    display: flex;
  }

  .julia-container.fullscreen-mode {
    position: relative;
  }

  .julia-container.fullscreen-mode,
  .julia-container.fullscreen-mode .canvas-container {
    width: 100vw;
    max-width: 100vw;
  }

  .julia-container.fullscreen-mode .canvas-container {
    height: calc(100vh - 24px);
  }

  .julia-container.fullscreen-mode #juliaCanvas {
    max-height: 100vh;
    min-height: auto;
  }

  .julia-container.fullscreen-mode .julia-toolbar,
  .julia-container.fullscreen-mode .julia-controls {
    position: absolute;
    left: 12px;
    right: 12px;
    z-index: 200;
    background: rgba(34, 34, 34, 0.9);
    backdrop-filter: blur(6px);
    border-radius: 8px;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
  }

  .julia-container.fullscreen-mode .julia-toolbar {
    top: 12px;
  }

  .julia-container.fullscreen-mode .julia-controls {
    top: 64px;
    max-height: 55vh;
    overflow: auto;
  }

  /* Erklärungsbox im Vollbildmodus: absolut positioniert und scrollbar */
  .julia-container.fullscreen-mode .explanation-container {
    position: absolute;
    bottom: 12px;
    left: 12px;
    right: 12px;
    z-index: 200;
    margin-top: 0;
  }

  .julia-container.fullscreen-mode .explanation-box {
    max-height: 45vh;
    overflow-y: auto;
    background: rgba(34, 34, 34, 0.95);
    backdrop-filter: blur(6px);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
  }

  .julia-container.fullscreen-mode .explanation-toggle {
    background: rgba(34, 34, 34, 0.9);
    backdrop-filter: blur(6px);
  }


  @media (max-width: 768px) {
    .julia-toolbar {
      gap: 6px;
    }
    .julia-toolbar .toggle-button {
      padding: 8px 10px;
    }
  }

  @media (max-width: 480px) {
    .julia-toolbar .btn-text {
      display: none;
    }
    .julia-toolbar .icon {
      margin-right: 0;
    }
    .julia-toolbar .toggle-button {
      padding: 10px 12px;
    }
  }
  
  /* ========================================
     Control Rows - Compact Inline Layout
     ======================================== */
  .control-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.04);
    transition: background 0.2s ease;
  }
  
  .control-row:hover {
    background: rgba(255, 255, 255, 0.05);
  }
  
  .control-row label {
    flex-shrink: 0;
    min-width: 70px;
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    font-weight: 500;
    text-align: left;
  }
  
  /* ========================================
     Color Intensity Group - Dropdown + Button zusammen
     ======================================== */
  .color-intensity-group {
    display: flex;
    gap: 8px;
    align-items: flex-end;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.04);
    transition: background 0.2s ease;
  }

  .color-intensity-group:hover {
    background: rgba(255, 255, 255, 0.05);
  }

  .color-intensity-group .color-control-item {
    flex: 1 1 auto;
    min-width: 120px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 0;
  }

  /* Fix: Farben Tom-Select Wrapper auf sichtbare Höhe begrenzen */
  .color-control-item .ts-wrapper {
    width: 100%;
    max-width: 100%;
    height: fit-content; /* Höhe nur so groß wie der sichtbare Inhalt */
  }

  .color-control-item .ts-wrapper .ts-dropdown {
    width: 100% !important;
    min-width: 0 !important;
    max-width: 100% !important;
    left: 0 !important;
    right: auto !important;
    box-sizing: border-box !important;
  }

  .color-intensity-group .intensity-toggle {
    flex: 0 0 auto;
    padding: 8px 12px;
    white-space: nowrap;
    align-self: flex-end;
    height: fit-content;
  }

  /* ========================================
     Color Control Item - Basis-Styles
     ======================================== */
  .color-control-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.04);
    transition: background 0.2s ease;
    flex: 0 1 auto;
  }
  
  /* Desktop: Compact dropdown width */
  @media (min-width: 900px) {
    .controls-basic .color-control-item {
      min-width: 150px;
      max-width: 180px;
    }
    
    .controls-basic .color-control-item select {
      width: auto;
      min-width: 120px;
    }

    .color-controls-row .intensity-toggle {
      max-width: 100px;
    }
  }
  
  .color-control-item:hover {
    background: rgba(255, 255, 255, 0.05);
  }
  
  /* Fix: Innerhalb color-intensity-group soll color-control-item KEINEN hover haben */
  .color-intensity-group .color-control-item:hover {
    background: none;
  }
  
  .color-control-item label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 12px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .color-control-item select,
  .color-control-item button {
    width: 100%;
  }
  
  /* ========================================
     noUiSlider Custom Styles
     ======================================== */
  .nouislider-wrapper {
    flex: 1;
    margin: 0 8px;
    min-width: 100px;
  }
  
  .nouislider-wrapper .noUi-target {
    background: rgba(255, 255, 255, 0.16);
    border: none;
    border-radius: 999px;
    box-shadow: none;
    height: 6px;
  }
  
  .nouislider-wrapper .noUi-connect {
    background: linear-gradient(90deg, #05d9e8, #4aa3ff);
    border-radius: 999px;
  }
  
  .nouislider-wrapper .noUi-handle {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #4aa3ff;
    border: 2px solid rgba(0, 0, 0, 0.25);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    cursor: pointer;
    top: -8px;
    right: -10px;
  }
  
  .nouislider-wrapper .noUi-handle::before,
  .nouislider-wrapper .noUi-handle::after {
    display: none;
  }
  
  .nouislider-wrapper .noUi-handle:hover {
    background: #5cb8ff;
    transform: scale(1.1);
  }
  
  .nouislider-wrapper .noUi-handle:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(74, 163, 255, 0.4), 0 2px 6px rgba(0, 0, 0, 0.4);
  }
  
  /* Mobile: Größerer Slider für Touch */
  @media (max-width: 768px) {
    .nouislider-wrapper .noUi-target {
      height: 8px;
    }
    
    .nouislider-wrapper .noUi-handle {
      width: 28px;
      height: 28px;
      top: -10px;
      right: -14px;
    }
  }
  
  /* ========================================
     Value Chip - Compact Display
     ======================================== */
  .value-chip {
    flex-shrink: 0;
    min-width: 52px;
    padding: 5px 10px;
    color: #05d9e8;
    font-size: 13px;
    font-weight: 600;
    font-family: 'SF Mono', 'Consolas', monospace;
    text-align: center;
    border-radius: 8px;
    background: rgba(5, 217, 232, 0.1);
    border: 1px solid rgba(5, 217, 232, 0.2);
  }
  
  /* ========================================
     Preset Row - c-Werte Auswahl
     ======================================== */
  .preset-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.04);
  }

  .preset-row label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 12px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }

  .preset-row .preset-select,
  .preset-row .ts-wrapper {
    flex: 1;
    min-width: 0;
  }

  /* ========================================
     Toggle Row - Kompakte Inline Buttons
     ======================================== */
  .toggle-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    padding-top: 10px;
    margin-top: 4px;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
  }

  .toggle-row .toggle-button.compact {
    flex: 1;
    min-width: 120px;
    padding: 8px 12px;
    font-size: 12px;
  }

  .toggle-row .toggle-button.icon-only {
    flex: 0 0 auto;
    padding: 8px 12px;
    min-width: auto;
  }

  .toggle-row .toggle-button.icon-only .icon {
    margin: 0;
  }

  /* ========================================
     General Button Styling
     ======================================== */
  .julia-container button {
    background: rgba(255, 255, 255, 0.04);
    color: #eacfb4;
    border: 1px solid rgba(255, 255, 255, 0.08);
    padding: 10px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    min-height: 40px; /* Touch-friendly */
  }

  .julia-container button:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(5, 217, 232, 0.3);
    transform: translateY(-1px);
  }

  .julia-container button:active {
    transform: scale(0.98) translateY(0);
  }
  
  /* ========================================
     Tom Select - Custom Dark Theme
     ======================================== */
  .julia-controls .ts-wrapper {
    width: 100%;
  }
  
  .julia-controls .ts-wrapper.single .ts-control {
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 8px 14px;
    min-height: 40px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: none;
  }
  
  .julia-controls .ts-wrapper.single .ts-control:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(5, 217, 232, 0.3);
  }
  
  .julia-controls .ts-wrapper.single.focus .ts-control {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(5, 217, 232, 0.5);
    box-shadow: 0 0 0 3px rgba(5, 217, 232, 0.15);
  }
  
  .julia-controls .ts-control,
  .julia-controls .ts-control input {
    color: #fff;
    font-size: 13px;
  }
  
  .julia-controls .ts-control input::placeholder {
    color: rgba(255, 255, 255, 0.5);
  }
  
  /* Dropdown Arrow */
  .julia-controls .ts-wrapper.single .ts-control::after {
    border-color: rgba(255, 255, 255, 0.5) transparent transparent transparent;
    margin-top: -2px;
  }
  
  .julia-controls .ts-wrapper.single.dropdown-active .ts-control::after {
    border-color: transparent transparent #05d9e8 transparent;
  }
  
  /* Dropdown Menu */
  .julia-controls .ts-dropdown {
    background: #1e1e1e;
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    margin-top: 4px;
    overflow: hidden;
  }
  
  /* Dropdown-Breite begrenzen auf Control-Breite */
  .julia-controls .ts-wrapper {
    position: relative;
  }
  
  /* Fix: Preset Dropdown an Wrapper-Breite binden */
  .preset-row .ts-wrapper .ts-dropdown {
    width: 100% !important;
    min-width: 0 !important;
    max-width: 100% !important;
    left: 0 !important;
    right: auto !important;
    box-sizing: border-box !important;
  }
  
  .julia-controls .ts-dropdown .ts-dropdown-content {
    padding: 6px;
    max-height: 250px;
  }
  
  .julia-controls .ts-dropdown .option {
    padding: 10px 14px;
    color: rgba(255, 255, 255, 0.8);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    font-size: 13px;
  }
  
  .julia-controls .ts-dropdown .option:hover,
  .julia-controls .ts-dropdown .option.active {
    background: rgba(5, 217, 232, 0.15);
    color: #fff;
  }
  
  .julia-controls .ts-dropdown .option.selected {
    background: rgba(5, 217, 232, 0.25);
    color: #05d9e8;
  }
  
  /* Hide native select (fallback) */
  .julia-controls select.tomselected {
    display: none !important;
  }
  
  /* ========================================
     Mobile Responsive - Controls Panel
     ======================================== */
  @media (max-width: 768px) {
    .julia-controls {
      padding: 14px;
    }
    
    .control-row {
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .control-row label {
      width: 100%;
      min-width: unset;
      margin-bottom: 2px;
    }
    
    .nouislider-wrapper {
      flex: 1 1 100%;
      margin: 0;
      order: 1;
    }
    
    .control-row .value-chip {
      order: 2;
      margin-left: auto;
    }
    
    .color-controls-row {
      flex-direction: row;
      flex-wrap: wrap;
    }
  }
  
  @media (max-width: 480px) {
    .julia-controls {
      padding: 12px;
      border-radius: 10px;
    }
    
    .control-row,
    .color-control-item {
      padding: 8px 10px;
    }
    
    .control-row label,
    .color-control-item label {
      font-size: 12px;
    }
    
    .button-row {
      gap: 6px;
    }
    
    .julia-container button {
      padding: 8px 12px;
      font-size: 12px;
      flex: 1;
      min-width: 0;
    }
  }
  
  .canvas-container {
    position: relative;
    width: 100%;
    margin: 0 auto;
  }
  
  #juliaCanvas {
    display: block;
    width: 100%;
    height: auto;
    border-radius: 4px;
    cursor: crosshair;
    aspect-ratio: 16/9;
    max-height: 70vh;
    min-height: 320px;
    touch-action: none;
  }

  @media (min-width: 1024px) {
    #juliaCanvas {
      max-height: 75vh;
      min-height: 380px;
    }
  }

  @media (max-width: 768px) {
    #juliaCanvas {
      max-height: 65vh;
      min-height: 200px;
    }

    .julia-container.focus-mode #juliaCanvas {
      max-height: calc(100vh - 140px);
      min-height: clamp(260px, 60vh, 520px);
    }

    .btn-text {
      display: inline;
      font-size: 11px;
    }
  }
  
  .loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
    display: none;
    font-size: 16px;
  }
  
  #zoomBox {
    position: absolute;
    border: 2px dashed #ff00ff;
    background: rgba(255, 0, 255, 0.15);
    pointer-events: none;
    display: none;
  }

  .zoom-warning {
    position: absolute;
    left: 12px;
    bottom: 12px;
    background: rgba(0, 0, 0, 0.75);
    color: #ffd1d1;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    display: none;
    z-index: 6;
  }
  
  .explanation-container {
    margin-top: 20px;
    display: block;
  }
  
  .explanation-toggle {
    width: 100%;
    text-align: center;
    margin-bottom: 0;
    background: linear-gradient(145deg, rgba(42, 42, 42, 0.95), rgba(30, 30, 30, 0.98));
    color: #05d9e8;
    padding: 12px 16px;
    border: 1px solid rgba(5, 217, 232, 0.3);
    border-radius: 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  .explanation-toggle:hover {
    background: linear-gradient(145deg, rgba(50, 50, 50, 0.95), rgba(35, 35, 35, 0.98));
    border-color: rgba(5, 217, 232, 0.5);
    box-shadow: 0 0 15px rgba(5, 217, 232, 0.2);
  }
  
  .explanation-toggle.active {
    background: linear-gradient(145deg, rgba(5, 217, 232, 0.15), rgba(5, 217, 232, 0.08));
    border-color: rgba(5, 217, 232, 0.5);
  }
  
  .explanation-box {
    background: linear-gradient(145deg, rgba(42, 42, 42, 0.95), rgba(30, 30, 30, 0.98));
    border: 1px solid rgba(5, 217, 232, 0.2);
    border-radius: 12px;
    padding: 20px;
    margin-top: 12px;
    color: #e0e0e0;
    font-size: 14px;
    line-height: 1.6;
    display: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    /* Scrollbar für lange Erklärungen - größer im normalen Modus */
    max-height: 70vh;
    overflow-y: auto;
  }
  
  /* Scroll-Schatten oben/unten für bessere UX */
  .explanation-box.visible {
    display: block;
    background: 
      linear-gradient(rgba(42, 42, 42, 0.98) 30%, transparent),
      linear-gradient(transparent, rgba(30, 30, 30, 0.98) 70%) 0 100%,
      linear-gradient(145deg, rgba(42, 42, 42, 0.95), rgba(30, 30, 30, 0.98));
    background-size: 100% 20px, 100% 20px, 100% 100%;
    background-repeat: no-repeat;
    background-attachment: local, local, scroll;
  }
  
  /* Responsive: Kleinere max-height auf Mobilgeräten */
  @media (max-width: 768px) {
    .explanation-box {
      max-height: 40vh;
    }
  }
  
  .explanation-box h3 {
    margin: 0 0 20px 0;
    color: #ff00ff;
    font-size: 1.25rem;
    font-weight: 600;
    border-bottom: 2px solid rgba(255, 0, 255, 0.5);
    padding-bottom: 12px;
  }
  
  .explanation-box h4 {
    margin: 0;
    color: #05d9e8;
    font-size: 1rem;
    font-weight: 600;
    border-bottom: 1px solid rgba(5, 217, 232, 0.3);
    padding-bottom: 8px;
    margin-bottom: 12px;
  }
  
  .explanation-box h5 {
    margin: 0 0 6px 0;
    color: #d1f7ff;
    font-size: 0.875rem;
    font-weight: 500;
  }
  
  .explanation-section {
    margin-bottom: 20px;
  }
  
  .explanation-section:last-child {
    margin-bottom: 0;
  }
  
  .param-group {
    margin: 12px 0;
    padding-left: 12px;
    border-left: 2px solid rgba(5, 217, 232, 0.2);
  }
  
  .explanation-box p {
    margin: 0 0 10px 0;
  }
  
  .explanation-box p.hint {
    font-style: italic;
    color: #a0a0a0;
    font-size: 0.85rem;
  }
  
  .explanation-box code {
    background: rgba(5, 217, 232, 0.1);
    color: #05d9e8;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
  }
  
  .explanation-box ul {
    margin: 8px 0;
    padding-left: 0;
    list-style: none;
  }
  
  .explanation-box li {
    position: relative;
    padding-left: 16px;
    margin-bottom: 6px;
  }
  
  .explanation-box li::before {
    content: '›';
    position: absolute;
    left: 0;
    color: #05d9e8;
    font-weight: bold;
  }
  
  .explanation-box strong {
    color: #05d9e8;
  }
  
  .color-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  
  .color-tag {
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.15);
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.8rem;
    color: #d1f7ff;
  }
  
  .nav-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 12px;
  }
  
  @media (max-width: 500px) {
    .nav-columns {
      grid-template-columns: 1fr;
    }
  }
  
  .nav-column h5 {
    margin-bottom: 8px;
    color: #ff00ff;
  }

  /* General select styling (outside .julia-controls) */
  select,
  option,
  optgroup {
    background: rgba(255, 255, 255, 0.06);
    color: #fff;
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 10px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    line-height: 1.2;
  }
  
  select.auto-width {
    width: auto;
  }
  
  .canvas-overlay {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 120;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .overlay-item {
    background: rgba(0, 0, 0, 0.55);
    color: #eacfb4;
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
    backdrop-filter: blur(4px);
  }
  /* Toggle-Button Styling */
  .toggle-button {
    background: rgba(255, 255, 255, 0.04);
    color: #ddd;
    border: 1px solid rgba(255, 255, 255, 0.12);
    padding: 8px 12px;
    border-radius: 999px;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 100px;
    text-align: center;
  }
  
  .toggle-button.active {
    background: rgba(5, 217, 232, 0.3) !important;
    color: #fff !important;
    border-color: rgba(5, 217, 232, 0.6) !important;
    /* Verstärkter Glow für Safari/iOS Kompatibilität */
    -webkit-box-shadow: 0 0 8px 2px rgba(5, 217, 232, 0.6), inset 0 0 4px rgba(5, 217, 232, 0.2);
    box-shadow: 0 0 8px 2px rgba(5, 217, 232, 0.6), inset 0 0 4px rgba(5, 217, 232, 0.2);
  }
  
  /* Seitlicher Zoom-Regler für Smartphones */
  .mobile-zoom-control {
    position: absolute;
    right: 10px;
    bottom: 70px; /* Position über der Info-Panel */
    display: none; /* Standardmäßig ausgeblendet, wird per JavaScript für Mobilgeräte aktiviert */
    flex-direction: row;
    align-items: center;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 15px;
    padding: 6px 8px;
    z-index: 100;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  
  /* Angepasste Position für den mobilen Zoom-Regler */
  @media (max-width: 768px) {
    .mobile-zoom-control {
      right: 5px;
      bottom: 70px; /* Position über der Info-Panel */
      flex-direction: row;
      padding: 5px 6px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 12px;
    }
    
    .zoom-button {
      width: 26px;
      height: 26px;
      font-size: 16px;
    }
    
    .zoom-level-display {
      font-size: 12px;
      padding: 2px 5px;
      min-width: 40px;
    }
  }
  
  .zoom-buttons-container {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .zoom-button {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #444;
    color: white;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    padding: 0;
    line-height: 1;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    border: none;
  }
  
  .zoom-button:hover {
    background: #555;
  }
  
  .zoom-button:active {
    transform: scale(0.95);
    box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);
  }
  
  .zoom-level-display {
    color: white;
    font-size: 13px;
    background: rgba(0, 0, 0, 0.3);
    padding: 2px 6px;
    border-radius: 8px;
    text-align: center;
    min-width: 45px;
    font-weight: normal;
    margin: 0 3px;
  }
</style>

<script src="{{ site.baseurl }}/assets/js/fractal-renderer.js"></script>
<script>
window.__fractalNewJulia = true;

// Erklärbox-Funktionalität - GLOBAL definiert für onclick
function toggleExplanationBox(button) {
  const explanationBox = document.getElementById('explanationBox');
  if (!explanationBox) {
    console.error('explanationBox not found');
    return;
  }
  
  const isOpen = explanationBox.classList.contains('visible');
  
  if (isOpen) {
    explanationBox.classList.remove('visible');
    button.classList.remove('active');
    button.innerHTML = 'Erklärung anzeigen <span style="font-size: 10px;">▼</span>';
  } else {
    explanationBox.classList.add('visible');
    button.classList.add('active');
    button.innerHTML = 'Erklärung ausblenden <span style="font-size: 10px;">▲</span>';
  }
}

document.addEventListener('DOMContentLoaded', function() {
  const container = document.querySelector('.julia-container');
  const canvas = document.getElementById('juliaCanvas');
  const loadingIndicator = document.getElementById('loadingIndicator');
  const zoomBox = document.getElementById('zoomBox');

  // noUiSlider Elements
  const realPartSliderEl = document.getElementById('realPartSlider');
  const imagPartSliderEl = document.getElementById('imagPartSlider');
  const maxIterSliderEl = document.getElementById('maxIterationsSlider');
  
  // Initialize noUiSlider for Real Part
  noUiSlider.create(realPartSliderEl, {
    start: -0.7,
    connect: [true, false],
    step: 0.01,
    range: { 'min': -2, 'max': 2 },
    format: { to: v => v.toFixed(2), from: v => Number(v) }
  });
  
  // Initialize noUiSlider for Imaginary Part
  noUiSlider.create(imagPartSliderEl, {
    start: 0.27,
    connect: [true, false],
    step: 0.01,
    range: { 'min': -2, 'max': 2 },
    format: { to: v => v.toFixed(2), from: v => Number(v) }
  });
  
  // Initialize noUiSlider for Iterations
  noUiSlider.create(maxIterSliderEl, {
    start: 250,
    connect: [true, false],
    step: 10,
    range: { 'min': 10, 'max': 1000 },
    format: { to: v => Math.round(v), from: v => Number(v) }
  });

  // Tom Select für Farbschema-Dropdown initialisieren
  const colorSchemeSelect = document.getElementById('colorScheme');
  window.colorSchemeTomSelect = null;
  if (colorSchemeSelect && typeof TomSelect !== 'undefined') {
    window.colorSchemeTomSelect = new TomSelect('#colorScheme', {
      create: false,
      sortField: null, // Reihenfolge beibehalten
      controlInput: null, // Kein Suchfeld
      allowEmptyOption: false,
      onChange: function(value) {
        // Farbschema aktualisieren und neu rendern
        state.colorScheme = value;
        requestRender({ immediate: true, reason: 'colorScheme' });
      }
    });
  }

  // Tom Select für Preset-Dropdown initialisieren
  const presetSelect = document.getElementById('presetValues');
  let presetTomSelect = null;
  if (presetSelect && typeof TomSelect !== 'undefined') {
    presetTomSelect = new TomSelect('#presetValues', {
      create: false,
      sortField: null,
      controlInput: null,
      allowEmptyOption: false,
      onChange: function(value) {
        const option = presetSelect.querySelector(`option[value="${value}"]`);
        if (option) {
          const realVal = parseFloat(option.dataset.real);
          const imagVal = parseFloat(option.dataset.imag);
          // Slider aktualisieren
          realPartSliderEl.noUiSlider.set(realVal);
          imagPartSliderEl.noUiSlider.set(imagVal);
          // State aktualisieren
          state.realPart = realVal;
          state.imagPart = imagVal;
          // Neu rendern
          requestRender({ preview: true, debounce: 100, reason: 'preset' });
        }
      }
    });
  }
  
  const colorIntensityButton = document.getElementById('colorIntensity');
  const applyButton = document.getElementById('applySettings');
  const resetZoomButton = document.getElementById('resetZoom');
  const saveImageButton = document.getElementById('saveImage');
  const advancedToggleButton = document.getElementById('juliaAdvancedToggle');
  const focusModeButton = document.getElementById('juliaFocusMode');
  const fullscreenButton = document.getElementById('juliaFullscreen');
  const zoomInButton = container.querySelector('#juliaZoomIn');
  const zoomOutButton = container.querySelector('#juliaZoomOut');
  const juliaZoomLevel = container.querySelector('#juliaZoomLevel');
  const juliaMobileZoom = container.querySelector('#juliaMobileZoom');
  const allowExtremeZoomButton = document.getElementById('allowExtremeZoom');
  const zoomWarning = document.getElementById('zoomWarning');

  const realValueSpan = document.getElementById('realValue');
  const imagValueSpan = document.getElementById('imagValue');
  const iterValueSpan = document.getElementById('iterValue');
  const positionInfoSpan = document.getElementById('positionInfo');
  const zoomInfoSpan = document.getElementById('zoomInfo');
  const mousePositionSpan = document.getElementById('mousePosition');
  const complexValueSpan = document.getElementById('complexValue');
  const iterationInfoSpan = document.getElementById('iterationInfo');

  const defaultSettings = {
    realPart: -0.7,
    imagPart: 0.27015,
    maxIterations: 250,
    colorScheme: 'retrowave'
  };

  const state = {
    realPart: defaultSettings.realPart,
    imagPart: defaultSettings.imagPart,
    maxIterations: defaultSettings.maxIterations,
    colorScheme: defaultSettings.colorScheme,
    useIntense: false,
    allowExtremeZoom: false,
    viewX: 0,
    viewY: 0,
    zoomLevel: 1
  };

  const MIN_ZOOM = 0.5;
  const MAX_ZOOM_DEFAULT = 5000;
  const MAX_ZOOM_EXTREME = 500000;
  const ZOOM_WARNING_THRESHOLD = 100000;

  const renderer = new FractalRenderer({
    canvas,
    loadingIndicator,
    workerUrl: '{{ site.baseurl }}/assets/js/julia-worker.js',
    type: 'julia',
    allowIterationData: true,
    maxWorkers: FractalUtils.isMobileDevice() ? 2 : (navigator.hardwareConcurrency || 4),
    maxCanvasPixels: 1920 * 1080,
    previewScale: 0.55
  });

  function getMaxZoom() {
    return state.allowExtremeZoom ? MAX_ZOOM_EXTREME : MAX_ZOOM_DEFAULT;
  }

  function updateZoomWarning() {
    if (!zoomWarning) return;
    zoomWarning.style.display = state.zoomLevel >= ZOOM_WARNING_THRESHOLD ? 'block' : 'none';
  }

  renderer.onViewUpdate = (view) => {
    zoomInfoSpan.textContent = FractalUtils.formatZoomLevel(view.zoomLevel);
    if (juliaZoomLevel) juliaZoomLevel.textContent = view.zoomLevel.toFixed(2) + '×';
    updateZoomWarning();
    // Aktualisiere c-Wert mit Mittelpunkt (wichtig für Mobile)
    updateCenterInfo();
  };

  function setButtonLabel(button, label) {
    if (!button) return;
    const text = button.querySelector('.btn-text');
    if (text) text.textContent = label;
  }

  function syncRendererState() {
    const palettes = state.useIntense ? FractalPalettes.intense : FractalPalettes.standard;
    if (!palettes[state.colorScheme]) {
      state.colorScheme = 'blau-rot';
      colorSchemeSelect.value = state.colorScheme;
    }
    renderer.setState({
      viewX: state.viewX,
      viewY: state.viewY,
      zoomLevel: state.zoomLevel,
      maxIterations: state.maxIterations,
      colorScheme: state.colorScheme,
      colorPalettes: palettes,
      realPart: state.realPart,
      imagPart: state.imagPart
    });
  }

  function requestRender(options) {
    const settings = options || {};
    syncRendererState();
    if (settings.preview) {
      renderer.drawPreview();
    }
    if (settings.immediate) {
      renderer.render({ preview: false, reason: settings.reason || 'immediate' });
    } else {
      renderer.scheduleRender({ debounce: settings.debounce || 200, reason: settings.reason || 'scheduled' });
    }
  }

  function resizeAndRender() {
    const container = canvas.parentElement;
    renderer.resizeToContainer(container);
    requestRender({ immediate: true, reason: 'resize' });
  }

  function screenToComplex(canvasX, canvasY) {
    const xRange = 3 / state.zoomLevel;
    const yRange = 3 / state.zoomLevel;
    return {
      cx: state.viewX - xRange / 2 + (canvasX / canvas.width) * xRange,
      cy: state.viewY - yRange / 2 + (canvasY / canvas.height) * yRange
    };
  }

  function getCanvasCoords(event) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
      x: (event.clientX - rect.left) * scaleX,
      y: (event.clientY - rect.top) * scaleY
    };
  }

  function updateInfoFromEvent(event) {
    const pos = getCanvasCoords(event);
    const complex = screenToComplex(pos.x, pos.y);
    if (mousePositionSpan) mousePositionSpan.textContent = `${Math.round(pos.x)} / ${Math.round(pos.y)}`;
    if (complexValueSpan) complexValueSpan.textContent = `${complex.cx.toFixed(4)} + ${complex.cy.toFixed(4)}i`;
    if (positionInfoSpan) positionInfoSpan.textContent = `${complex.cx.toFixed(4)} + ${complex.cy.toFixed(4)}i`;
    if (iterationInfoSpan) {
      const iteration = renderer.getIterationAt(pos.x, pos.y);
      iterationInfoSpan.textContent = iteration === null ? '–' : iteration;
    }
  }

  // Aktualisiert die c-Wert Anzeige mit dem Mittelpunkt des Canvas (für Mobile/Touch)
  function updateCenterInfo() {
    // Der Mittelpunkt des sichtbaren Bereichs ist state.viewX + state.viewY*i
    if (positionInfoSpan) {
      positionInfoSpan.textContent = `${state.viewX.toFixed(4)} + ${state.viewY.toFixed(4)}i`;
    }
  }

  function animateZoomTo(targetZoom, centerX, centerY) {
    const xRangeNew = 3 / targetZoom;
    const yRangeNew = 3 / targetZoom;
    const complexAtCursor = screenToComplex(centerX, centerY);
    const targetViewX = complexAtCursor.cx - (centerX / canvas.width) * xRangeNew + xRangeNew / 2;
    const targetViewY = complexAtCursor.cy - (centerY / canvas.height) * yRangeNew + yRangeNew / 2;
    renderer.animateTo({ viewX: targetViewX, viewY: targetViewY, zoomLevel: targetZoom }, 140);
    state.viewX = targetViewX;
    state.viewY = targetViewY;
    state.zoomLevel = targetZoom;
  }

  function adjustFontSize() {
    const infoPanel = document.querySelector('.info-panel');
    if (!infoPanel) return;
    const textElements = document.querySelectorAll('.info-row');
    const containerWidth = infoPanel.offsetWidth - 20;
    textElements.forEach(element => {
      let fontSize = 16;
      element.style.fontSize = fontSize + 'px';
      while (element.scrollWidth > containerWidth && fontSize > 8) {
        fontSize -= 0.5;
        element.style.fontSize = fontSize + 'px';
      }
    });
  }

  // noUiSlider Event Handlers
  realPartSliderEl.noUiSlider.on('update', function(values) {
    realValueSpan.textContent = values[0];
    state.realPart = parseFloat(values[0]);
  });

  realPartSliderEl.noUiSlider.on('change', function() {
    requestRender({ preview: true, debounce: 150, reason: 'realPart' });
  });

  imagPartSliderEl.noUiSlider.on('update', function(values) {
    imagValueSpan.textContent = values[0];
    state.imagPart = parseFloat(values[0]);
  });

  imagPartSliderEl.noUiSlider.on('change', function() {
    requestRender({ preview: true, debounce: 150, reason: 'imagPart' });
  });

  maxIterSliderEl.noUiSlider.on('update', function(values) {
    iterValueSpan.textContent = values[0];
    state.maxIterations = parseInt(values[0], 10);
  });
  
  maxIterSliderEl.noUiSlider.on('change', function() {
    requestRender({ preview: true, debounce: 220, reason: 'iterations' });
  });

  applyButton.addEventListener('click', function() {
    state.colorScheme = colorSchemeSelect.value;
    requestRender({ immediate: true, reason: 'apply' });
  });

  resetZoomButton.addEventListener('click', function() {
    state.viewX = 0;
    state.viewY = 0;
    state.zoomLevel = 1;
    renderer.animateTo({ viewX: 0, viewY: 0, zoomLevel: 1 }, 180);
    requestRender({ immediate: true, reason: 'reset' });
  });

  saveImageButton.addEventListener('click', function() {
    const link = document.createElement('a');
    link.download = 'julia-menge.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  if (colorIntensityButton) {
    colorIntensityButton.addEventListener('click', function() {
      state.useIntense = !state.useIntense;
      this.classList.toggle('active', state.useIntense);
      setButtonLabel(colorIntensityButton, state.useIntense ? 'Intensiv' : 'Subtil');
      requestRender({ preview: true, debounce: 200, reason: 'palette' });
    });
  }

  if (allowExtremeZoomButton) {
    allowExtremeZoomButton.addEventListener('click', function() {
      state.allowExtremeZoom = !state.allowExtremeZoom;
      this.classList.toggle('active', state.allowExtremeZoom);
      setButtonLabel(allowExtremeZoomButton, 'Extremzoom: ' + (state.allowExtremeZoom ? 'An' : 'Aus'));
      if (!state.allowExtremeZoom && state.zoomLevel > MAX_ZOOM_DEFAULT) {
        state.zoomLevel = MAX_ZOOM_DEFAULT;
        renderer.animateTo({ viewX: state.viewX, viewY: state.viewY, zoomLevel: state.zoomLevel }, 160);
        requestRender({ immediate: true, reason: 'limit-clamp' });
      }
      updateZoomWarning();
    });
  }

  if (advancedToggleButton) {
    advancedToggleButton.addEventListener('click', function() {
      container.classList.toggle('advanced-open');
      this.classList.toggle('active', container.classList.contains('advanced-open'));
      // Canvas im Vollbildmodus neu berechnen
      setTimeout(resizeAndRender, 100);
    });
  }

  if (focusModeButton) {
    focusModeButton.addEventListener('click', function() {
      container.classList.toggle('focus-mode');
      this.classList.toggle('active', container.classList.contains('focus-mode'));
      // Canvas im Vollbildmodus neu berechnen
      setTimeout(resizeAndRender, 100);
    });
  }

  if (fullscreenButton) {
    fullscreenButton.addEventListener('click', function() {
      if (!document.fullscreenElement) {
        container.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    });
    document.addEventListener('fullscreenchange', function() {
      const isFullscreen = !!document.fullscreenElement;
      container.classList.toggle('fullscreen-mode', isFullscreen);
      setButtonLabel(fullscreenButton, isFullscreen ? 'Vollbild aus' : 'Vollbild');
      setTimeout(resizeAndRender, 80);
    });
  }

  if (zoomInButton) {
    zoomInButton.addEventListener('click', function() {
      const targetZoom = FractalUtils.clamp(state.zoomLevel * 1.2, MIN_ZOOM, getMaxZoom());
      animateZoomTo(targetZoom, canvas.width / 2, canvas.height / 2);
      requestRender({ debounce: 200, reason: 'zoom-in' });
    });
  }

  if (zoomOutButton) {
    zoomOutButton.addEventListener('click', function() {
      const targetZoom = FractalUtils.clamp(state.zoomLevel / 1.2, MIN_ZOOM, getMaxZoom());
      animateZoomTo(targetZoom, canvas.width / 2, canvas.height / 2);
      requestRender({ debounce: 200, reason: 'zoom-out' });
    });
  }

  let isPanning = false;
  let lastPan = null;
  let isDrawingZoomBox = false;
  let zoomBoxStart = null;
  let zoomBoxStartCss = null;
  let activePointerId = null;
  let isSpacePanning = false;

  function getCssCoords(event) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    };
  }

  function beginZoomBox(cssPos, canvasPos) {
    isDrawingZoomBox = true;
    zoomBoxStart = canvasPos;
    zoomBoxStartCss = cssPos;
    zoomBox.style.display = 'block';
    zoomBox.style.left = cssPos.x + 'px';
    zoomBox.style.top = cssPos.y + 'px';
    zoomBox.style.width = '0px';
    zoomBox.style.height = '0px';
  }

  function updateZoomBox(cssPos) {
    if (!zoomBoxStartCss) return;
    const left = Math.min(cssPos.x, zoomBoxStartCss.x);
    const top = Math.min(cssPos.y, zoomBoxStartCss.y);
    const width = Math.abs(cssPos.x - zoomBoxStartCss.x);
    const height = Math.abs(cssPos.y - zoomBoxStartCss.y);
    zoomBox.style.left = left + 'px';
    zoomBox.style.top = top + 'px';
    zoomBox.style.width = width + 'px';
    zoomBox.style.height = height + 'px';
    return { width, height };
  }

  function endZoomBox(canvasPos, cssPos) {
    if (!zoomBoxStart || !zoomBoxStartCss) return;
    const size = updateZoomBox(cssPos);
    zoomBox.style.display = 'none';
    isDrawingZoomBox = false;
    if (size && size.width > 10 && size.height > 10) {
      const centerX = (canvasPos.x + zoomBoxStart.x) / 2;
      const centerY = (canvasPos.y + zoomBoxStart.y) / 2;
      const zoomX = canvas.width / Math.abs(canvasPos.x - zoomBoxStart.x);
      const zoomY = canvas.height / Math.abs(canvasPos.y - zoomBoxStart.y);
      const targetZoom = FractalUtils.clamp(state.zoomLevel * Math.min(zoomX, zoomY), MIN_ZOOM, getMaxZoom());
      animateZoomTo(targetZoom, centerX, centerY);
      requestRender({ debounce: 180, reason: 'zoom-box' });
    }
    zoomBoxStart = null;
    zoomBoxStartCss = null;
  }

  canvas.addEventListener('pointerdown', function(event) {
    if (event.pointerType === 'touch') return;
    if (activePointerId !== null) return;
    activePointerId = event.pointerId;
    canvas.setPointerCapture(event.pointerId);
    const canvasPos = getCanvasCoords(event);
    const cssPos = getCssCoords(event);
    // c-Wert bei Klick aktualisieren
    updateInfoFromEvent(event);
    if (event.button === 2 || isSpacePanning) {
      isPanning = true;
      lastPan = canvasPos;
      return;
    }
    if (event.button !== 0) return;
    beginZoomBox(cssPos, canvasPos);
  });

  canvas.addEventListener('pointermove', function(event) {
    if (event.pointerType === 'touch') return;
    
    // Immer c-Wert aktualisieren bei Mausbewegung
    updateInfoFromEvent(event);
    
    // Rest nur wenn Pointer aktiv (Klick gehalten)
    if (activePointerId !== event.pointerId) return;
    
    if (isDrawingZoomBox && zoomBoxStart) {
      updateZoomBox(getCssCoords(event));
      return;
    }
    if (isPanning && lastPan) {
      const canvasPos = getCanvasCoords(event);
      const dx = canvasPos.x - lastPan.x;
      const dy = canvasPos.y - lastPan.y;
      const xRange = 3 / state.zoomLevel;
      const yRange = 3 / state.zoomLevel;
      state.viewX -= (dx / canvas.width) * xRange;
      state.viewY -= (dy / canvas.height) * yRange;
      lastPan = canvasPos;
      renderer.setState({ viewX: state.viewX, viewY: state.viewY, zoomLevel: state.zoomLevel });
      renderer.drawPreview();
      renderer.scheduleRender({ debounce: 180, reason: 'pan' });
    }
  });

  canvas.addEventListener('pointerup', function(event) {
    if (event.pointerType === 'touch') return;
    if (activePointerId !== event.pointerId) return;
    const canvasPos = getCanvasCoords(event);
    if (isDrawingZoomBox && zoomBoxStart) {
      endZoomBox(canvasPos, getCssCoords(event));
    }
    isPanning = false;
    activePointerId = null;
    // c-Wert nach Interaktion aktualisieren
    updateInfoFromEvent(event);
  });

  canvas.addEventListener('pointercancel', function(event) {
    if (event.pointerType === 'touch') return;
    if (activePointerId !== event.pointerId) return;
    isPanning = false;
    isDrawingZoomBox = false;
    zoomBox.style.display = 'none';
    zoomBoxStart = null;
    zoomBoxStartCss = null;
    activePointerId = null;
  });

  canvas.addEventListener('contextmenu', function(event) {
    event.preventDefault();
  });

  window.addEventListener('keydown', function(event) {
    if (event.code === 'Space') {
      isSpacePanning = true;
    }
  });

  window.addEventListener('keyup', function(event) {
    if (event.code === 'Space') {
      isSpacePanning = false;
    }
  });

  canvas.addEventListener('wheel', function(event) {
    event.preventDefault();
    const pos = getCanvasCoords(event);
    const zoomFactor = Math.exp(-event.deltaY * 0.0016);
    const targetZoom = FractalUtils.clamp(state.zoomLevel * zoomFactor, MIN_ZOOM, getMaxZoom());
    animateZoomTo(targetZoom, pos.x, pos.y);
    requestRender({ debounce: 220, reason: 'wheel' });
    // c-Wert nach Zoom aktualisieren
    updateInfoFromEvent(event);
  }, { passive: false });

  canvas.addEventListener('dblclick', function(event) {
    event.preventDefault();
    const pos = getCanvasCoords(event);
    const targetZoom = FractalUtils.clamp(state.zoomLevel / 2, MIN_ZOOM, getMaxZoom());
    animateZoomTo(targetZoom, pos.x, pos.y);
    requestRender({ debounce: 180, reason: 'dblclick-out' });
    // c-Wert nach Zoom aktualisieren
    updateInfoFromEvent(event);
  });

  let lastTouchDistance = 0;
  let lastTouchCenter = null;
  let lastTouchTime = 0;

  canvas.addEventListener('touchstart', function(event) {
    if (event.touches.length === 2) {
      const [t1, t2] = event.touches;
      lastTouchDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      lastTouchCenter = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
    } else if (event.touches.length === 1) {
      const rect = canvas.getBoundingClientRect();
      lastPan = {
        x: (event.touches[0].clientX - rect.left) * (canvas.width / rect.width),
        y: (event.touches[0].clientY - rect.top) * (canvas.height / rect.height)
      };
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', function(event) {
    event.preventDefault();
    const now = performance.now();
    if (now - lastTouchTime < 30) return;
    lastTouchTime = now;
    const rect = canvas.getBoundingClientRect();
    if (event.touches.length === 2 && lastTouchCenter) {
      const [t1, t2] = event.touches;
      const distance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const center = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
      const zoomFactor = distance / (lastTouchDistance || distance);
      const targetZoom = FractalUtils.clamp(state.zoomLevel * zoomFactor, MIN_ZOOM, getMaxZoom());
      const canvasX = (center.x - rect.left) * (canvas.width / rect.width);
      const canvasY = (center.y - rect.top) * (canvas.height / rect.height);
      animateZoomTo(targetZoom, canvasX, canvasY);
      lastTouchDistance = distance;
      lastTouchCenter = center;
      requestRender({ debounce: 220, reason: 'pinch' });
    } else if (event.touches.length === 1 && lastPan) {
      const x = (event.touches[0].clientX - rect.left) * (canvas.width / rect.width);
      const y = (event.touches[0].clientY - rect.top) * (canvas.height / rect.height);
      const dx = x - lastPan.x;
      const dy = y - lastPan.y;
      const xRange = 3 / state.zoomLevel;
      const yRange = 3 / state.zoomLevel;
      state.viewX -= (dx / canvas.width) * xRange;
      state.viewY -= (dy / canvas.height) * yRange;
      lastPan = { x, y };
      renderer.setState({ viewX: state.viewX, viewY: state.viewY, zoomLevel: state.zoomLevel });
      renderer.drawPreview();
      renderer.scheduleRender({ debounce: 200, reason: 'pan-touch' });
    }
  }, { passive: false });

  canvas.addEventListener('touchend', function() {
    lastPan = null;
    lastTouchCenter = null;
    lastTouchDistance = 0;
    // Aktualisiere c-Wert nach Touch-Interaktion
    updateCenterInfo();
  });

  function updateMobileControls() {
    if (!juliaMobileZoom) return;
    const isMobile = FractalUtils.isMobileDevice() || window.innerWidth <= 768;
    juliaMobileZoom.style.display = isMobile ? 'flex' : 'none';
  }

  window.addEventListener('resize', function() {
    adjustFontSize();
    updateMobileControls();
    resizeAndRender();
  });

  if (typeof ResizeObserver !== 'undefined') {
    const resizeObserver = new ResizeObserver(() => resizeAndRender());
    resizeObserver.observe(canvas.parentElement);
  }

  realValueSpan.textContent = state.realPart;
  imagValueSpan.textContent = state.imagPart;
  iterValueSpan.textContent = state.maxIterations;
  colorSchemeSelect.value = state.colorScheme;
  if (allowExtremeZoomButton) {
    setButtonLabel(allowExtremeZoomButton, state.allowExtremeZoom ? 'An' : 'Aus');
  }
  updateZoomWarning();
  adjustFontSize();
  updateMobileControls();
  updateCenterInfo(); // Initial c-Wert setzen
  resizeAndRender();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  if (window.__fractalNewJulia) {
    return;
  }
  // Hilfsfunktion zur Formatierung der Zoom-Stufe
  function formatZoomLevel(level) {
    if (level >= 10) {
      return level.toFixed(0) + '×';
    } else if (level >= 1) {
      return level.toFixed(1) + '×';
    } else {
      return level.toFixed(2) + '×';
    }
  }
  
  // Canvas und Kontext
  const canvas = document.getElementById('juliaCanvas');
  const ctx = canvas.getContext('2d');
  const loadingIndicator = document.getElementById('loadingIndicator');
  const zoomBox = document.getElementById('zoomBox');
  
  // Steuerelemente
  const realPartSlider = document.getElementById('realPart');
  const imagPartSlider = document.getElementById('imagPart');
  const maxIterSlider = document.getElementById('maxIterations');
  const colorSchemeSelect = document.getElementById('colorScheme');
  const colorIntensityButton = document.getElementById('colorIntensity');
  const applyButton = document.getElementById('applySettings');
  const resetZoomButton = document.getElementById('resetZoom');
  const saveImageButton = document.getElementById('saveImage');
  const advancedToggleButton = document.getElementById('juliaAdvancedToggle');
  const focusModeButton = document.getElementById('juliaFocusMode');
  const fullscreenButton = document.getElementById('juliaFullscreen');
  
  // Anzeige-Elemente
  const realValueSpan = document.getElementById('realValue');
  const imagValueSpan = document.getElementById('imagValue');
  const iterValueSpan = document.getElementById('iterValue');
  const positionInfoSpan = document.getElementById('positionInfo');
  const zoomInfoSpan = document.getElementById('zoomInfo');
  
  // Automatische Anpassung der Schriftgröße
  function adjustFontSize() {
    const container = document.querySelector('.info-panel');
    const textElements = document.querySelectorAll('.info-row');
    const containerWidth = container.offsetWidth - 20; // 20px Padding
    
    textElements.forEach(element => {
      // Starte mit einer größeren Schriftgröße
      let fontSize = 16;
      element.style.fontSize = fontSize + 'px';
      
      // Reduziere die Schriftgröße, bis der Text passt
      while (element.scrollWidth > containerWidth && fontSize > 8) {
        fontSize -= 0.5;
        element.style.fontSize = fontSize + 'px';
      }
    });
    
    // Auch für Labels und Buttons anpassen
    const labels = document.querySelectorAll('.control-row label');
    const buttons = document.querySelectorAll('.button-row button');
    
    [...labels, ...buttons].forEach(element => {
      let fontSize = 14;
      element.style.fontSize = fontSize + 'px';
      
      while (element.scrollWidth > element.offsetWidth && fontSize > 8) {
        fontSize -= 0.5;
        element.style.fontSize = fontSize + 'px';
      }
    });
  }
  
  // Passe die Schriftgröße an, wenn sich die Fenstergröße ändert
  window.addEventListener('resize', adjustFontSize);
  
  // Standardeinstellungen
  const defaultSettings = {
    realPart: -0.7,
    imagPart: 0.27015,
    maxIterations: 250,
    colorScheme: 'retrowave'
  };
  
  // Initialisierung der Steuerelemente
  let realPart = defaultSettings.realPart;
  let imagPart = defaultSettings.imagPart;
  let maxIterations = defaultSettings.maxIterations;
  let colorScheme = defaultSettings.colorScheme;
  
  // Ansichtsparameter
  let viewX = 0;
  let viewY = 0;
  let zoomLevel = 1;
  const zoomFactor = 1.5;
  
  // Zoom-Box Parameter
  let isZoomBoxActive = true;
  let isDrawingZoomBox = false;
  let zoomBoxStartX = 0;
  let zoomBoxStartY = 0;
  
  // Für Echtzeit-Informationen
  let iterationData = null;
  let isCalculating = false;
  
  // Farbpaletten mit mehr Magenta-Tönen
  const colorPalettes = {
    'blau-rot': ['#000764', '#206BCB', '#EDFFFF', '#FFB847', '#FB0C00'],
    'cyberpunk': ['#ff00ff', '#9600ff', '#0000ff', '#00ffff', '#00ffcc', '#ff00cc'],
    'retrowave': ['#ff00ff', '#9600ff', '#0000ff', '#00ffff', '#00ffcc', '#ff00cc', '#ff00ff'],
    'feuer': ['#000000', '#340000', '#800000', '#ff0000', '#ffff00', '#ffffff'],
    'ozean': ['#000033', '#000066', '#0000ff', '#00ffff', '#ffffff', '#00ffff'],
    'monochrom': ['#000000', '#222222', '#444444', '#666666', '#888888', '#aaaaaa', '#cccccc', '#ffffff'],
    'regenbogen': ['#ff00ff', '#ff8000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#8000ff', '#ff00ff'],
    'ultraviolett': ['#000000', '#2E0854', '#5A1A9A', '#7B52AB', '#9470DC', '#B490FF', '#DCACFF', '#FFFFFF'],
    'goldgrün': ['#071A07', '#0B3B0B', '#0E640E', '#11C411', '#30FF30', '#88FF88', '#DFFFDF', '#FFFFFF']
  };
  
  // Erweiterte Farbpaletten für intensivere Farbverläufe
  const intensePalettes = {
    'blau-rot': ['#000764', '#0C3B9E', '#206BCB', '#4E9CED', '#EDFFFF', '#FFCE89', '#FFB847', '#FF7847', '#FB0C00'],
    'cyberpunk': ['#ff00ff', '#d400ff', '#a900ff', '#7e00ff', '#5300ff', '#2700ff', '#001eff', '#0069ff', '#00b4ff', '#00ffff', '#00ffb4', '#00ff69', '#00ff1e', '#27ff00', '#53ff00', '#7eff00', '#a9ff00', '#d4ff00', '#ffff00', '#ffd400', '#ffa900', '#ff7e00', '#ff5300', '#ff2700', '#ff001e', '#ff0069', '#ff00b4', '#ff00ff'],
    'retrowave': ['#ff00ff', '#f700f7', '#d100ff', '#9f00ff', '#5500ff', '#2300ff', '#0014ff', '#0046ff', '#0078ff', '#00a9ff', '#00d9ff', '#00ffff', '#00ffdc', '#00ffb0', '#00ff83', '#00ff55', '#00ff28', '#19ff00', '#64ff00', '#b0ff00', '#ffff00', '#ffdc00', '#ffb000', '#ff8300', '#ff5500', '#ff2800', '#ff0019', '#ff0064', '#ff00b0', '#ff00ff'],
    'feuer': ['#000000', '#1C0000', '#340000', '#550000', '#800000', '#AA0000', '#D40000', '#FF0000', '#FF4000', '#FF8000', '#FFC000', '#FFFF00', '#FFFFAA', '#FFFFFF'],
    'ozean': ['#000033', '#000044', '#000066', '#000088', '#0000AA', '#0000CC', '#0000FF', '#0055FF', '#00AAFF', '#00FFFF', '#55FFFF', '#AAFFFF', '#FFFFFF', '#AAFFFF', '#00FFFF'],
    'monochrom': ['#000000', '#111111', '#222222', '#333333', '#444444', '#555555', '#666666', '#777777', '#888888', '#999999', '#aaaaaa', '#bbbbbb', '#cccccc', '#dddddd', '#eeeeee', '#ffffff'],
    'regenbogen': ['#ff00ff', '#ff00cc', '#ff0099', '#ff0066', '#ff0033', '#ff0000', '#ff3300', '#ff6600', '#ff9900', '#ffcc00', '#ffff00', '#ccff00', '#99ff00', '#66ff00', '#33ff00', '#00ff00', '#00ff33', '#00ff66', '#00ff99', '#00ffcc', '#00ffff', '#00ccff', '#0099ff', '#0066ff', '#0033ff', '#0000ff', '#3300ff', '#6600ff', '#9900ff', '#cc00ff', '#ff00ff'],
    'ultraviolett': ['#000000', '#150429', '#2E0854', '#44127E', '#5A1A9A', '#6B36A3', '#7B52AB', '#876EB4', '#9470DC', '#A480E8', '#B490FF', '#C59DFF', '#DCACFF', '#E9CBFF', '#F5E9FF', '#FFFFFF'],
    'goldgrün': ['#071A07', '#09280A', '#0B3B0B', '#0C500C', '#0E640E', '#0F790F', '#118E11', '#10A710', '#11C411', '#20D820', '#30FF30', '#59FF59', '#88FF88', '#B0FFB0', '#DFFFDF', '#FFFFFF']
  };
  
  // Standardmäßig intensive Farbverläufe verwenden
  let useIntensePalettes = false;
  let activePalettes = colorPalettes;
  
  // Optimierte Berechnung mit mehreren Web Workers
  function calculateJulia() {
    loadingIndicator.style.display = 'block';
    isCalculating = true;
    
    // Verwende requestAnimationFrame für bessere Performance
    requestAnimationFrame(() => {
      if (window.Worker) {
        // Anzahl der Worker (Prozessorkerne)
        let numWorkers = navigator.hardwareConcurrency || 4; // Fallback auf 4 Worker
        
        // Reduziere die Anzahl der Worker auf Mobilgeräten
        if (isMobileDevice()) {
          numWorkers = Math.min(2, numWorkers); // Maximal 2 Worker auf Mobilgeräten
          
          // Reduziere auch die maximalen Iterationen, wenn sie zu hoch sind
          if (maxIterations > 500 && zoomLevel > 10) {
            const originalIterations = maxIterations;
            maxIterations = Math.min(maxIterations, 500);
            console.log(`Reduziere Iterationen von ${originalIterations} auf ${maxIterations} für bessere mobile Performance`);
          }
        }
        
        // Beende alle laufenden Worker, falls vorhanden
        if (window.activeJuliaWorkers && window.activeJuliaWorkers.length > 0) {
          console.log('Beende laufende Worker vor dem Start neuer Berechnungen');
          window.activeJuliaWorkers.forEach(worker => {
            if (worker) {
              worker.terminate();
            }
          });
        }
        
        // Initialisiere das Array für aktive Worker
        window.activeJuliaWorkers = [];
        
        const workers = [];
        const chunks = [];
        let completedChunks = 0;
        
        // Canvas in Chunks aufteilen
        const chunkHeight = Math.ceil(canvas.height / numWorkers);
        
        if (!activePalettes[colorScheme]) {
          console.error("Farbschema nicht gefunden:", colorScheme);
          colorScheme = 'blau-rot'; // Fallback auf Standard-Farbschema
          colorSchemeSelect.value = colorScheme;
        }
        
        // Direkt hochauflösend berechnen
        startMultiWorkerCalculation();
        
        function startMultiWorkerCalculation() {
          // Erstelle Worker für jeden Chunk
          for (let i = 0; i < numWorkers; i++) {
            const startY = i * chunkHeight;
            const endY = Math.min(startY + chunkHeight, canvas.height);
            
            const worker = new Worker('{{ site.baseurl }}/assets/js/julia-worker.js');
            workers.push(worker);
            window.activeJuliaWorkers.push(worker);
            
            worker.postMessage({
              width: canvas.width,
              height: canvas.height,
              realPart: realPart,
              imagPart: imagPart,
              maxIterations: maxIterations,
              colorScheme: colorScheme,
              viewX: viewX,
              viewY: viewY,
              zoomLevel: zoomLevel,
              colorPalettes: activePalettes,
              startY: startY,
              endY: endY,
              workerId: i
            });
            
            worker.onmessage = function(e) {
              const result = e.data;
              chunks[result.workerId] = result;
              completedChunks++;
              
              // Zeichne diesen Chunk sofort
              ctx.putImageData(
                result.imageData, 
                0, 
                result.startY, 
                0, 
                0, 
                canvas.width, 
                result.endY - result.startY
              );
              
              // Wenn alle Chunks fertig sind
              if (completedChunks === numWorkers) {
                loadingIndicator.style.display = 'none';
                zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
                
                // Speichere Iterationsdaten für Echtzeit-Informationen
                if (result.iterationData) {
                  iterationData = result.iterationData;
                }
                
                isCalculating = false;
                
                // Bereinige Worker
                workers.forEach(w => {
                  w.terminate();
                  // Entferne Worker aus dem aktiven Array
                  const index = window.activeJuliaWorkers.indexOf(w);
                  if (index !== -1) {
                    window.activeJuliaWorkers.splice(index, 1);
                  }
                });
              }
            };
            
            // Fehlerbehandlung für Worker
            worker.onerror = function(e) {
              console.error('Worker-Fehler:', e);
              loadingIndicator.style.display = 'none';
              isCalculating = false;
              
              // Bereinige alle Worker bei einem Fehler
              workers.forEach(w => {
                w.terminate();
                const index = window.activeJuliaWorkers.indexOf(w);
                if (index !== -1) {
                  window.activeJuliaWorkers.splice(index, 1);
                }
              });
              
              // Zeige Fehlermeldung an
              alert('Bei der Berechnung ist ein Fehler aufgetreten. Bitte versuchen Sie es mit weniger Iterationen oder einem geringeren Zoom-Level.');
            };
          }
        }
      } else {
        // Fallback für Browser ohne Web Worker-Unterstützung
        calculateJuliaDirectly();
      }
    });
  }
  
  // Hilfsfunktion: HEX zu RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ] : [0, 0, 0];
  }
  
  // Event-Listener für Steuerelemente (synchrone Aktualisierung der Anzeige)
  realPartSlider.addEventListener('input', function() {
    realValueSpan.textContent = this.value;
    // Aktualisiere Parameter sofort
    realPart = parseFloat(this.value);
    // Keine sofortige Neuberechnung, nur Anzeige aktualisieren
  });
  
  imagPartSlider.addEventListener('input', function() {
    imagValueSpan.textContent = this.value;
    // Aktualisiere Parameter sofort
    imagPart = parseFloat(this.value);
    // Keine sofortige Neuberechnung, nur Anzeige aktualisieren
  });
  
  maxIterSlider.addEventListener('input', function() {
    iterValueSpan.textContent = this.value;
    // Aktualisiere Parameter sofort
    maxIterations = parseInt(this.value);
    // Sofortige Neuberechnung mit Drosselung
    safeCalculateJulia();
  });
  
  // Anwenden-Button
  applyButton.addEventListener('click', function() {
    // Parameter wurden bereits durch die Slider aktualisiert
    // Überprüfe nur das Farbschema
    colorScheme = colorSchemeSelect.value;
    
    // Überprüfe, ob das Farbschema existiert
    if (!activePalettes[colorScheme]) {
      console.error("Farbschema nicht gefunden:", colorScheme);
      colorScheme = 'blau-rot'; // Fallback auf Standard-Farbschema
      colorSchemeSelect.value = colorScheme;
    }
    
    // Julia-Menge neu berechnen
    safeCalculateJulia();
  });
  
  // Farbschema-Auswahl via Tom-Select
  if (window.colorSchemeTomSelect) {
    window.colorSchemeTomSelect.on('change', function(value) {
      colorScheme = value;
      
      if (!activePalettes[colorScheme]) {
        console.error("Farbschema nicht gefunden:", colorScheme);
        colorScheme = 'blau-rot';
        this.setValue(colorScheme, true); // silent = true
      }
      
      // Julia-Menge neu berechnen
      safeCalculateJulia();
    });
  } else {
    // Fallback falls Tom-Select nicht geladen
    colorSchemeSelect.addEventListener('change', function() {
      colorScheme = this.value;
      
      if (!activePalettes[colorScheme]) {
        console.error("Farbschema nicht gefunden:", colorScheme);
        colorScheme = 'blau-rot';
        colorSchemeSelect.value = colorScheme;
      }
      
      safeCalculateJulia();
    });
  }
  
  // Farbintensitäts-Button
  colorIntensityButton.addEventListener('click', function() {
    useIntensePalettes = !useIntensePalettes;
    
    // Button-Zustand aktualisieren
    if (useIntensePalettes) {
      setButtonLabel(this, 'Intensiv');
      this.classList.add('active');
      activePalettes = intensePalettes;
    } else {
      setButtonLabel(this, 'Subtil');
      this.classList.remove('active');
      activePalettes = colorPalettes;
    }
    
    // Julia-Menge neu berechnen
    safeCalculateJulia();
  });
  
  resetZoomButton.addEventListener('click', function() {
    viewX = 0;
    viewY = 0;
    zoomLevel = 1;
    zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
    safeCalculateJulia();
  });
  
  saveImageButton.addEventListener('click', function() {
    const link = document.createElement('a');
    link.download = 'julia-set.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });
  
  // Maus-Events für Zoom und Navigation
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    
    // Mausposition im Canvas
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Position im komplexen Koordinatensystem
    const xRange = 3.0 / zoomLevel;
    const yRange = 3.0 / zoomLevel;
    const xMouse = viewX + (mouseX / canvas.width - 0.5) * xRange;
    const yMouse = viewY + (mouseY / canvas.height - 0.5) * yRange;
    
    // Zoom anpassen
    if (e.deltaY < 0) {
      zoomLevel *= zoomFactor;
    } else {
      zoomLevel /= zoomFactor;
    }
    
    // Begrenzung des Zooms
    zoomLevel = Math.max(0.1, Math.min(1000, zoomLevel));
    
    // Ansicht auf Mausposition zentrieren
    viewX = xMouse;
    viewY = yMouse;
    
    // Zoom-Info aktualisieren
    zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
    
    // Aktualisiere auch den mobilen Zoom-Wert
    if (juliaZoomLevel) {
      juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
    }
    
    safeCalculateJulia();
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (isCalculating) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Umrechnung in komplexen Koordinaten
    const xRange = 3.0 / zoomLevel;
    const yRange = 3.0 / zoomLevel;
    const xMin = viewX - xRange / 2;
    const yMin = viewY - yRange / 2;
    
    const complexX = xMin + (x / canvas.width) * xRange;
    const complexY = yMin + (y / canvas.height) * yRange;
    
    // Anzeige der Position und komplexen Zahl
    document.getElementById('mousePosition').textContent = `(${x.toFixed(0)}, ${y.toFixed(0)})`;
    document.getElementById('complexValue').textContent = `${complexX.toFixed(6)} + ${complexY.toFixed(6)}i`;
    positionInfoSpan.textContent = `${complexX.toFixed(4)} + ${complexY.toFixed(4)}i`;
    
    // Iterationsinfo aktualisieren, falls verfügbar
    if (iterationData) {
      const pixelX = Math.floor(x * (iterationData.width / canvas.width));
      const pixelY = Math.floor(y * (iterationData.height / canvas.height));
      
      if (pixelX >= 0 && pixelX < iterationData.width && pixelY >= 0 && pixelY < iterationData.height) {
        const index = (pixelY * iterationData.width + pixelX);
        const iterations = iterationData.data[index];
        document.getElementById('iterationInfo').textContent = iterations === maxIterations ? 'In der Menge' : iterations;
      }
    }
    
    // Zoom-Box zeichnen, wenn aktiv und Maus gedrückt
    if (isZoomBoxActive && isDrawingZoomBox) {
      const width = x - zoomBoxStartX;
      const height = y - zoomBoxStartY;
      
      // Setze die Position und Größe der Zoom-Box
      zoomBox.style.left = (width < 0 ? zoomBoxStartX + width : zoomBoxStartX) + 'px';
      zoomBox.style.top = (height < 0 ? zoomBoxStartY + height : zoomBoxStartY) + 'px';
      zoomBox.style.width = Math.abs(width) + 'px';
      zoomBox.style.height = Math.abs(height) + 'px';
    }
  });
  
  canvas.addEventListener('mousedown', function(e) {
    if (isZoomBoxActive) {
      const rect = canvas.getBoundingClientRect();
      zoomBoxStartX = e.clientX - rect.left;
      zoomBoxStartY = e.clientY - rect.top;
      
      isDrawingZoomBox = true;
      zoomBox.style.display = 'block';
      zoomBox.style.left = zoomBoxStartX + 'px';
      zoomBox.style.top = zoomBoxStartY + 'px';
      zoomBox.style.width = '0';
      zoomBox.style.height = '0';
    }
  });
  
  canvas.addEventListener('mouseup', function(e) {
    if (isZoomBoxActive && isDrawingZoomBox) {
      isDrawingZoomBox = false;
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Nur zoomen, wenn die Box eine Mindestgröße hat
      const boxWidth = Math.abs(mouseX - zoomBoxStartX);
      const boxHeight = Math.abs(mouseY - zoomBoxStartY);
      
      if (boxWidth > 10 && boxHeight > 10) {
        // Berechne die Grenzen der Box im komplexen Koordinatensystem
        const xRange = 3.0 / zoomLevel;
        const yRange = 3.0 / zoomLevel;
        
        const x1 = viewX + (Math.min(zoomBoxStartX, mouseX) / canvas.width - 0.5) * xRange;
        const x2 = viewX + (Math.max(zoomBoxStartX, mouseX) / canvas.width - 0.5) * xRange;
        const y1 = viewY + (Math.min(zoomBoxStartY, mouseY) / canvas.height - 0.5) * yRange;
        const y2 = viewY + (Math.max(zoomBoxStartY, mouseY) / canvas.height - 0.5) * yRange;
        
        // Neuer Mittelpunkt - exakt in der Mitte der Box
        viewX = (x1 + x2) / 2;
        viewY = (y1 + y2) / 2;
        
        // Berechne den neuen Zoom-Level basierend auf der Box-Größe
        const newXRange = x2 - x1;
        const newYRange = y2 - y1;
        const aspectRatio = canvas.width / canvas.height;
        
        // Wähle den kleineren Zoom-Faktor, um sicherzustellen, dass die gesamte Box sichtbar ist
        if (newXRange / newYRange > aspectRatio) {
          zoomLevel = 3.0 / newXRange;
        } else {
          zoomLevel = 3.0 / (newYRange * aspectRatio);
        }
        
        // Zoom-Info aktualisieren
        zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
        
        // Aktualisiere auch den mobilen Zoom-Wert
        if (juliaZoomLevel) {
          juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
        }
        
        safeCalculateJulia();
      }
      
      zoomBox.style.display = 'none';
    }
  });
  
  canvas.addEventListener('click', function(e) {
    if (!isZoomBoxActive) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Position im komplexen Koordinatensystem
      const xRange = 3.0 / zoomLevel;
      const yRange = 3.0 / zoomLevel;
      const xMouse = viewX + (mouseX / canvas.width - 0.5) * xRange;
      const yMouse = viewY + (mouseY / canvas.height - 0.5) * yRange;
      
      // Zentriere die Ansicht auf die Mausposition
      viewX = xMouse;
      viewY = yMouse;
      
      // Zoom-Info aktualisieren (obwohl sich der Zoom-Level nicht ändert)
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      safeCalculateJulia();
    }
  });
  
  canvas.addEventListener('dblclick', function(e) {
    if (!isZoomBoxActive) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Position im komplexen Koordinatensystem
      const xRange = 3.0 / zoomLevel;
      const yRange = 3.0 / zoomLevel;
      const xMouse = viewX + (mouseX / canvas.width - 0.5) * xRange;
      const yMouse = viewY + (mouseY / canvas.height - 0.5) * yRange;
      
      // Zentriere die Ansicht auf die Mausposition und zoome hinein
      viewX = xMouse;
      viewY = yMouse;
      zoomLevel *= 2;
      
      // Zoom-Info aktualisieren
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      // Aktualisiere auch den mobilen Zoom-Wert
      if (juliaZoomLevel) {
        juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
      }
      
      safeCalculateJulia();
    }
  });
  
  // Initialisierung
  realValueSpan.textContent = realPartSlider.value;
  imagValueSpan.textContent = imagPartSlider.value;
  iterValueSpan.textContent = maxIterSlider.value;
  // Zoom-Box bleibt aktiv (Button entfernt)
  
  // Initialisiere mobile Steuerungen
  setupMobileControls();

  function setButtonLabel(button, text) {
    if (!button) return;
    const label = button.querySelector('.btn-text');
    if (label) {
      label.textContent = text;
    } else {
      button.textContent = text;
    }
  }

  // Erweiterte Steuerungen ein-/ausblenden
  function setAdvancedOpen(enabled) {
    const container = document.querySelector('.julia-container');
    if (!container || !advancedToggleButton) return;
    container.classList.toggle('advanced-open', enabled);
    advancedToggleButton.setAttribute('aria-expanded', enabled);
    // Button-Text und Title aktualisieren
    setButtonLabel(advancedToggleButton, enabled ? 'Optionen ausblenden' : 'Erweiterte Optionen');
    advancedToggleButton.title = enabled ? 'Erweiterte Optionen ausblenden' : 'Erweiterte Optionen anzeigen';
    // Canvas im Vollbildmodus neu berechnen
    setTimeout(resizeAndRender, 100);
  }

  if (advancedToggleButton) {
    advancedToggleButton.addEventListener('click', function() {
      const container = document.querySelector('.julia-container');
      if (!container) return;
      setAdvancedOpen(!container.classList.contains('advanced-open'));
    });
  }

  // Fokusmodus (kartenkompatibel, platzsparend)
  function setFocusMode(enabled) {
    const container = document.querySelector('.julia-container');
    if (!container || !focusModeButton) return;
    container.classList.toggle('focus-mode', enabled);
    focusModeButton.classList.toggle('active', enabled);
    focusModeButton.setAttribute('aria-pressed', String(enabled));
    setButtonLabel(focusModeButton, enabled ? 'Fokus aus' : 'Fokus');
    // Canvas im Vollbildmodus neu berechnen
    setTimeout(resizeAndRender, 100);
  }

  if (focusModeButton) {
    focusModeButton.addEventListener('click', function() {
      const container = document.querySelector('.julia-container');
      if (!container) return;
      setFocusMode(!container.classList.contains('focus-mode'));
    });
  }

  setFocusMode(true);

  // Vollbildmodus
  if (fullscreenButton) {
    fullscreenButton.addEventListener('click', function() {
      const container = document.querySelector('.julia-container');
      if (!container) return;
      if (!document.fullscreenElement) {
        container.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    });

    document.addEventListener('fullscreenchange', function() {
      const isFullscreen = !!document.fullscreenElement;
      setButtonLabel(fullscreenButton, isFullscreen ? 'Vollbild aus' : 'Vollbild');
      const container = document.querySelector('.julia-container');
      if (container) {
        container.classList.toggle('fullscreen-mode', isFullscreen);
      }
      adjustCanvasResolution();
    });
  }
  
  // Erste Berechnung mit reduzierter Auflösung auf Mobilgeräten
  if (isMobileDevice()) {
    // Reduziere die Auflösung und Iterationen für Mobilgeräte
    adjustCanvasResolution();
    // Verzögere die erste Berechnung leicht, um die UI zu initialisieren
    setTimeout(() => {
      calculateJulia();
    }, 100);
  } else {
    // Auf Desktop-Geräten sofort berechnen
    calculateJulia();
  }
  
  // Führe die Schriftgrößenanpassung nach dem Laden durch
  setTimeout(adjustFontSize, 100);
  
  // Touch-Variablen
  let lastTouchX = 0;
  let lastTouchY = 0;
  let touchCenterX = 0;
  let touchCenterY = 0;
  let lastTouchDistance = 0;
  let isTouching = false;
  let isZooming = false;
  
  // Variablen für Drosselung (Throttling)
  let touchThrottleTimer = null;
  const touchThrottleDelay = 150; // Verzögerung in Millisekunden
  
  // Aktualisiere Info-Text für Touch-Geräte
  function updateTouchInfo() {
    const isTouchDevice = ('ontouchstart' in window) || 
                          (navigator.maxTouchPoints > 0) || 
                          (navigator.msMaxTouchPoints > 0);
    
    if (isTouchDevice) {
      // Füge Info-Text für Touch-Geräte hinzu
      const infoBar = document.querySelector('.info-bar');
      if (infoBar) {
        // Prüfe, ob bereits ein Touch-Info-Element existiert
        if (!document.querySelector('.touch-info')) {
          const touchInfoElement = document.createElement('div');
          touchInfoElement.className = 'touch-info';
          touchInfoElement.innerHTML = '<p>Ein Finger: Verschieben | Doppeltippen: Zoom + | Zoom-Regler: Unten rechts</p>';
          touchInfoElement.style.width = '100%';
          touchInfoElement.style.textAlign = 'center';
          touchInfoElement.style.marginTop = '5px';
          touchInfoElement.style.padding = '5px';
          touchInfoElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
          touchInfoElement.style.borderRadius = '4px';
          infoBar.appendChild(touchInfoElement);
        }
      }
    }
  }
  
  // Führe die Aktualisierung der Info-Texte nach dem Laden durch
  setTimeout(updateTouchInfo, 200);

  // Drosselungsfunktion für Berechnungen
  let calculationThrottleTimer = null;
  const calculationThrottleDelay = 500; // 500ms Verzögerung
  
  function throttleCalculation(callback) {
    if (calculationThrottleTimer) {
      clearTimeout(calculationThrottleTimer);
    }
    
    calculationThrottleTimer = setTimeout(() => {
      callback();
      calculationThrottleTimer = null;
    }, calculationThrottleDelay);
  }
  
  // Funktion zum sicheren Berechnen mit Drosselung
  function safeCalculateJulia() {
    // Wenn bereits eine Berechnung läuft, diese abbrechen
    if (isCalculating) {
      console.log('Berechnung läuft bereits, breche ab und starte neu');
      // Beende alle laufenden Worker
      if (window.activeJuliaWorkers && window.activeJuliaWorkers.length > 0) {
        window.activeJuliaWorkers.forEach(worker => {
          if (worker) worker.terminate();
        });
        window.activeJuliaWorkers = [];
      }
      isCalculating = false;
    }
    
    // Drossele die Berechnung
    throttleCalculation(() => {
      calculateJulia();
    });
  }

  // Funktion zum Erkennen von Mobilgeräten
  function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }

  // Zeige oder verstecke mobile Zoom-Steuerungen basierend auf Gerätetyp
  function setupMobileControls() {
    const juliaMobileZoom = document.getElementById('juliaMobileZoom');
    
    if (isMobileDevice() || window.innerWidth <= 768) {
      // Zeige mobile Steuerungen auf Smartphones und Tablets
      if (juliaMobileZoom) juliaMobileZoom.style.display = 'flex';
      
      // Passe Auflösung für mobile Geräte an
      adjustCanvasResolution();
      
      // Passe die Position des Zoom-Controls an
      const infoPanel = document.querySelector('.info-panel');
      if (infoPanel && juliaMobileZoom) {
        const infoPanelHeight = infoPanel.offsetHeight;
        juliaMobileZoom.style.bottom = (infoPanelHeight + 10) + 'px';
      }
    } else {
      // Verstecke mobile Steuerungen auf Desktop
      if (juliaMobileZoom) juliaMobileZoom.style.display = 'none';
    }
  }

  // Funktion zur Anpassung der Canvas-Auflösung auf Mobilgeräten
  function adjustCanvasResolution() {
    // Prüfe, ob es sich um ein Mobilgerät handelt
    const isMobile = isMobileDevice();

    const container = canvas.parentElement;
    if (!container) return;

    const containerWidth = Math.floor(container.clientWidth || 0);
    if (!containerWidth) return;

    const maxWidth = isMobile ? 720 : 960;
    const minWidth = isMobile ? 320 : 480;
    const targetWidth = Math.max(minWidth, Math.min(maxWidth, containerWidth));
    const targetHeight = Math.floor(targetWidth * 9 / 16);

    if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
      canvas.width = targetWidth;
      canvas.height = targetHeight;
    }

    // Reduziere Iterationen auf mobilen Geräten nur bei sehr hohen Werten
    if (isMobile && maxIterations > 350) {
      maxIterSlider.value = 350;
      maxIterations = 350;
      iterValueSpan.textContent = maxIterations;
    }
  }

  // Zoom-Steuerung für Julia-Set
  const juliaZoomLevel = document.getElementById('juliaZoomLevel');
  const juliaZoomInBtn = document.getElementById('juliaZoomIn');
  const juliaZoomOutBtn = document.getElementById('juliaZoomOut');

  // Initialisiere Zoom-Wert-Anzeige
  if (juliaZoomLevel) {
    juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
  }

  // Zoom-Buttons für Julia-Set
  if (juliaZoomInBtn) {
    juliaZoomInBtn.addEventListener('click', function() {
      // Zoom-Faktor: 1.5x pro Klick
      zoomLevel = Math.min(zoomLevel * 1.5, 1000);
      
      // Aktualisiere Anzeige
      if (juliaZoomLevel) {
        juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
      }
      
      // Aktualisiere auch die Zoom-Info im Hauptbereich
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      calculateJulia();
    });
  }

  if (juliaZoomOutBtn) {
    juliaZoomOutBtn.addEventListener('click', function() {
      // Zoom-Faktor: 1.5x pro Klick (rückwärts)
      zoomLevel = Math.max(zoomLevel / 1.5, 0.1);
      
      // Aktualisiere Anzeige
      if (juliaZoomLevel) {
        juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
      }
      
      // Aktualisiere auch die Zoom-Info im Hauptbereich
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      calculateJulia();
    });
  }
  
  // Funktion zum Drosseln von Funktionsaufrufen
  function throttleTouch(callback, delay) {
    return function() {
      const context = this;
      const args = arguments;
      
      if (!touchThrottleTimer) {
        callback.apply(context, args);
        touchThrottleTimer = setTimeout(() => {
          touchThrottleTimer = null;
        }, delay);
      }
    };
  }
  
  // Variable für Doppeltipp-Erkennung
  let lastTapTime = 0;
  
  // Touch-Start-Handler
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    
    // Speichere die aktuelle Zeit für Doppeltipp-Erkennung
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTapTime;
    
    // Speichere die Berührungsposition
    if (e.touches.length === 1) {
      // Ein-Finger-Berührung für Verschiebung
      const touch = e.touches[0];
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      isTouching = true;
    } else if (e.touches.length === 2) {
      // Zwei-Finger-Berührung für Zoom
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      // Berechne Abstand zwischen den Fingern
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
      
      // Berechne Mittelpunkt der Berührung
      touchCenterX = (touch1.clientX + touch2.clientX) / 2;
      touchCenterY = (touch1.clientY + touch2.clientY) / 2;
      
      isZooming = true;
      isTouching = false;
    }
    
    // Doppeltipp-Erkennung für Zoom
    if (tapLength < 300 && tapLength > 0 && e.touches.length === 1) {
      // Doppeltipp erkannt - zoome hinein
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      // Berechne komplexe Koordinaten
      const complexX = viewX + (x / canvas.width - 0.5) * 4 / zoomLevel;
      const complexY = viewY + (y / canvas.height - 0.5) * 4 / zoomLevel;
      
      // Zoome hinein und zentriere auf Berührungspunkt
      zoomLevel *= 2;
      viewX = complexX;
      viewY = complexY;
      
      // Aktualisiere Zoom-Info
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      // Aktualisiere auch den mobilen Zoom-Wert
      if (juliaZoomLevel) {
        juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
      }
      
      // Berechne Julia-Set neu
      safeCalculateJulia();
      
      e.preventDefault();
    }
    
    lastTapTime = currentTime;
  });
  
  // Touch-Move-Handler
  canvas.addEventListener('touchmove', throttleTouch(function(e) {
    e.preventDefault();
    
    if (e.touches.length === 1 && isTouching) {
      // Ein-Finger-Verschiebung
      const touch = e.touches[0];
      const deltaX = touch.clientX - lastTouchX;
      const deltaY = touch.clientY - lastTouchY;
      
      // Berechne Verschiebung in komplexen Koordinaten
      const complexDeltaX = -deltaX * 4 / (canvas.width * zoomLevel);
      const complexDeltaY = -deltaY * 4 / (canvas.height * zoomLevel);
      
      // Aktualisiere Ansichtsposition
      viewX += complexDeltaX;
      viewY += complexDeltaY;
      
      // Aktualisiere letzte Berührungsposition
      lastTouchX = touch.clientX;
      lastTouchY = touch.clientY;
      
      // Berechne Julia-Set neu, wenn die Verschiebung signifikant ist
      if (Math.abs(deltaX) > 15 || Math.abs(deltaY) > 15) {
        safeCalculateJulia();
      }
    } else if (e.touches.length === 2 && isZooming) {
      // Zwei-Finger-Zoom
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      
      // Berechne neuen Abstand zwischen den Fingern
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      const newTouchDistance = Math.sqrt(dx * dx + dy * dy);
      
      // Berechne Zoom-Faktor
      const zoomFactor = newTouchDistance / lastTouchDistance;
      
      // Berechne neuen Mittelpunkt der Berührung
      const newTouchCenterX = (touch1.clientX + touch2.clientX) / 2;
      const newTouchCenterY = (touch1.clientY + touch2.clientY) / 2;
      
      // Aktualisiere Zoom-Level
      const oldZoomLevel = zoomLevel;
      zoomLevel *= zoomFactor;
      
      // Begrenze Zoom-Level
      zoomLevel = Math.max(0.1, Math.min(1000, zoomLevel));
      
      // Aktualisiere Ansichtsposition basierend auf Zoom und Mittelpunkt
      const rect = canvas.getBoundingClientRect();
      
      // Aktualisiere Zoom-Info
      zoomInfoSpan.textContent = formatZoomLevel(zoomLevel);
      
      // Aktualisiere auch den mobilen Zoom-Wert
      if (juliaZoomLevel) {
        juliaZoomLevel.textContent = formatZoomLevel(zoomLevel);
      }
      
      // Aktualisiere letzte Werte
      lastTouchDistance = newTouchDistance;
      touchCenterX = newTouchCenterX;
      touchCenterY = newTouchCenterY;
      
      // Berechne Julia-Set neu, wenn die Zoom-Änderung signifikant ist
      if (Math.abs(oldZoomLevel - zoomLevel) > 0.1) {
        safeCalculateJulia();
      }
    }
  }, 100)); // Erhöhte Drosselung für Touch-Events
  
  // Touch-End-Handler
  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    
    // Setze Flags zurück
    isTouching = false;
    isZooming = false;
    
    // Berechne Julia-Set neu mit voller Qualität
    safeCalculateJulia();
  });
});
</script> 