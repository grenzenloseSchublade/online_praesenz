{% comment %}
  Erweiterung des Standard-TOC von Minimal Mistakes mit optionaler Ausklapp-Funktionalität.
  Diese Datei wird in _layouts/single.html eingebunden und ersetzt die direkte Einbindung von toc.html.
  
  Die Ausklapp-Funktionalität wird aktiviert, wenn in der Front Matter toc_collapse: true gesetzt ist.
  Alle anderen TOC-Parameter (toc_label, toc_icon, toc_sticky) funktionieren weiterhin wie gewohnt.
  
  NEU: Mobile Sticky TOC Header - erscheint unter dem Masthead wenn das Original-TOC aus dem Viewport scrollt.
{% endcomment %}

{% assign toc_id_source = page.url | default: page.title | default: "toc" %}
{% assign toc_id = toc_id_source | slugify | prepend: "toc-" %}
{% assign toc_label = page.toc_label | default: site.data.ui-text[site.locale].toc_label | default: "Inhalt" %}

<!-- Mobile Sticky TOC Header (nur auf Mobile sichtbar) -->
<div id="toc-sticky-mobile" class="toc-sticky-mobile" aria-hidden="true">
  <button id="toc-sticky-toggle" class="toc-sticky-mobile__toggle" type="button" aria-expanded="false" aria-controls="toc-sticky-dropdown">
    <span class="toc-sticky-mobile__icon"><i class="fas fa-{{ page.toc_icon | default: 'list' }}"></i></span>
    <span class="toc-sticky-mobile__label">{{ toc_label }}:</span>
    <span id="toc-sticky-current" class="toc-sticky-mobile__current">–</span>
    <span class="toc-sticky-mobile__arrow">▼</span>
  </button>
  <div id="toc-sticky-dropdown" class="toc-sticky-mobile__dropdown">
    {% include toc.html sanitize=true html=content h_min=2 h_max=6 class="toc__menu toc-sticky-mobile__menu" skip_no_ids=true %}
  </div>
</div>
<div id="toc-sticky-overlay" class="toc-sticky-overlay" aria-hidden="true"></div>

<aside class="sidebar__right {% if page.toc_sticky %}sticky{% endif %}">
  <nav id="toc-original" class="toc" aria-label="{{ toc_label }}">
    {% if page.toc_collapse %}
      <button id="{{ toc_id }}-toggle" class="toc-toggle" type="button" aria-expanded="true" aria-controls="{{ toc_id }}-content">
        <h4 class="nav__title">
          <i class="fas fa-{{ page.toc_icon | default: 'file-alt' }}"></i> 
          {{ toc_label }}
          <span class="toc-toggle-icon">▲</span>
        </h4>
      </button>
      <div id="{{ toc_id }}-content" class="toc__menu-wrapper">
        {% include toc.html sanitize=true html=content h_min=2 h_max=6 class="toc__menu" skip_no_ids=true %}
      </div>
    {% else %}
      <header><h4 class="nav__title"><i class="fas fa-{{ page.toc_icon | default: 'file-alt' }}"></i> {{ toc_label }}</h4></header>
      {% include toc.html sanitize=true html=content h_min=2 h_max=6 class="toc__menu" skip_no_ids=true %}
    {% endif %}
  </nav>
</aside>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // ==========================================================================
  // MOBILE STICKY TOC FUNCTIONALITY
  // ==========================================================================
  const stickyToc = document.getElementById('toc-sticky-mobile');
  const stickyToggle = document.getElementById('toc-sticky-toggle');
  const stickyDropdown = document.getElementById('toc-sticky-dropdown');
  const stickyCurrent = document.getElementById('toc-sticky-current');
  const stickyOverlay = document.getElementById('toc-sticky-overlay');
  const originalToc = document.getElementById('toc-original');
  
  if (!stickyToc || !originalToc) return;
  
  const MOBILE_BREAKPOINT = 1024;
  let isDropdownOpen = false;
  let stickyVisible = false;
  
  // Cache für berechnete Werte (Performance)
  let cachedMastheadHeight = null;
  
  // Check if we're on mobile
  const isMobile = () => window.innerWidth < MOBILE_BREAKPOINT;
  
  // Masthead-Höhe mit Caching (wird bei Resize invalidiert)
  const getMastheadHeight = () => {
    if (cachedMastheadHeight === null) {
      const val = getComputedStyle(document.documentElement).getPropertyValue('--masthead-height').trim();
      cachedMastheadHeight = parseInt(val, 10) || 60;
    }
    return cachedMastheadHeight;
  };
  
  // ==========================================================================
  // VISIBILITY LOGIC: Sticky TOC nur zeigen wenn gescrollt UND TOC nicht sichtbar
  // ==========================================================================
  function updateStickyVisibility() {
    if (!isMobile()) {
      hideStickyToc();
      return;
    }
    
    const tocRect = originalToc.getBoundingClientRect();
    const mastheadHeight = getMastheadHeight();
    
    // TOC ist "aus dem Viewport" wenn seine Unterkante unter dem Masthead ist
    // UND wir tatsächlich nach unten gescrollt haben
    const tocBelowMasthead = tocRect.bottom < mastheadHeight;
    const hasScrolled = window.scrollY > 50;
    
    if (tocBelowMasthead && hasScrolled) {
      showStickyToc();
    } else {
      hideStickyToc();
    }
  }
  
  function showStickyToc() {
    if (!stickyVisible) {
      stickyVisible = true;
      stickyToc.classList.add('is-visible');
      stickyToc.setAttribute('aria-hidden', 'false');
      
      // Sticky TOC Höhe für anchor-offset berücksichtigen
      const stickyHeight = stickyToc.offsetHeight;
      document.documentElement.style.setProperty('--sticky-toc-height', stickyHeight + 'px');
    }
  }
  
  function hideStickyToc() {
    if (stickyVisible) {
      stickyVisible = false;
      stickyToc.classList.remove('is-visible');
      stickyToc.setAttribute('aria-hidden', 'true');
      closeDropdown();
      
      // Sticky TOC Höhe zurücksetzen
      document.documentElement.style.setProperty('--sticky-toc-height', '0px');
    }
  }
  
  // ==========================================================================
  // UNIFIED SCROLL HANDLER (Performance: nur ein Listener)
  // ==========================================================================
  let scrollTicking = false;
  window.addEventListener('scroll', function() {
    if (!scrollTicking) {
      requestAnimationFrame(function() {
        updateStickyVisibility();
        scrollTicking = false;
      });
      scrollTicking = true;
    }
  }, { passive: true });
  
  // Initial check
  updateStickyVisibility();
  
  // ==========================================================================
  // DROPDOWN FUNCTIONALITY
  // ==========================================================================
  function openDropdown() {
    isDropdownOpen = true;
    stickyToggle.setAttribute('aria-expanded', 'true');
    stickyToc.classList.add('is-open');
    stickyOverlay.classList.add('is-visible');
    stickyOverlay.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
  }
  
  function closeDropdown() {
    if (!isDropdownOpen) return;
    isDropdownOpen = false;
    stickyToggle.setAttribute('aria-expanded', 'false');
    stickyToc.classList.remove('is-open');
    stickyOverlay.classList.remove('is-visible');
    stickyOverlay.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
  }
  
  stickyToggle.addEventListener('click', function() {
    isDropdownOpen ? closeDropdown() : openDropdown();
  });
  
  // Overlay-Klick schließt Dropdown
  stickyOverlay.addEventListener('click', closeDropdown);
  
  // ESC-Taste schließt Dropdown
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && isDropdownOpen) {
      closeDropdown();
      stickyToggle.focus();
    }
  });
  
  // Klick auf TOC-Link: schließen (Smooth scroll wird von SmoothScroll-Lib übernommen)
  stickyDropdown.addEventListener('click', function(e) {
    if (e.target.tagName === 'A') {
      closeDropdown();
    }
  });
  
  // ==========================================================================
  // SCROLLSPY: Aktuelle Überschrift anzeigen
  // ==========================================================================
  let lastActiveText = '';
  let isAnimating = false;
  
  function updateCurrentHeading(newText) {
    if (!stickyCurrent || !newText) return;
    
    // Truncate wenn nötig
    const displayText = newText.length > 40 ? newText.substring(0, 37) + '...' : newText;
    
    // Nur aktualisieren wenn sich der Text geändert hat
    if (lastActiveText !== newText && !isAnimating) {
      lastActiveText = newText;
      isAnimating = true;
      
      // Slide-out Animation (nach oben)
      stickyCurrent.classList.add('is-sliding-out');
      
      setTimeout(() => {
        // Text ändern während unsichtbar
        stickyCurrent.textContent = displayText;
        stickyCurrent.classList.remove('is-sliding-out');
        
        // Slide-in Animation (von unten)
        stickyCurrent.classList.add('is-sliding-in');
        
        setTimeout(() => {
          stickyCurrent.classList.remove('is-sliding-in');
          isAnimating = false;
        }, 200);
      }, 150);
      
      // Auch im Dropdown das aktive Element markieren
      syncDropdownActive(newText);
    }
  }
  
  function syncDropdownActive(activeText) {
    // Entferne alte Markierungen im Dropdown
    stickyDropdown.querySelectorAll('li.active').forEach(li => li.classList.remove('active'));
    
    // Finde den passenden Link im Dropdown und markiere ihn
    stickyDropdown.querySelectorAll('a').forEach(link => {
      if (link.textContent.trim() === activeText) {
        link.parentElement.classList.add('active');
      }
    });
  }
  
  // ==========================================================================
  // EIGENER SCROLLSPY MIT BOTTOM-EDGE DETECTION
  // Kapitel wird aktiv wenn die UNTERKANTE der Überschrift den Header passiert
  // Gilt für Mobile UND Desktop für konsistentes Verhalten
  // ==========================================================================
  function initCustomScrollSpy() {
    // Alle Headings finden die im TOC verlinkt sind
    const tocLinks = originalToc.querySelectorAll('.toc__menu a[href^="#"]');
    const headingIds = Array.from(tocLinks).map(link => link.getAttribute('href').slice(1));
    const headings = headingIds
      .map(id => document.getElementById(id))
      .filter(el => el !== null);
    
    if (headings.length === 0) return;
    
    // Berechne den Trigger-Punkt (Masthead + ggf. Sticky-TOC)
    const getThreshold = () => {
      const mastheadH = getMastheadHeight();
      // Auf Mobile: Sticky-TOC Höhe berücksichtigen
      // Auf Desktop: Nur Masthead + kleiner Puffer
      const stickyH = (isMobile() && stickyVisible) ? stickyToc.offsetHeight : 0;
      return mastheadH + stickyH + 10;
    };
    
    let currentActiveIndex = -1;
    
    function updateActiveHeading() {
      const threshold = getThreshold();
      let newActiveIndex = -1;
      
      // Finde das letzte Heading dessen UNTERKANTE über dem Threshold ist
      // Das bedeutet: Die Überschrift ist komplett unter dem Header verschwunden
      for (let i = 0; i < headings.length; i++) {
        const rect = headings[i].getBoundingClientRect();
        if (rect.bottom <= threshold) {
          newActiveIndex = i;
        } else {
          // Sonderfall: Erstes Heading ist noch sichtbar aber teilweise über dem Threshold
          if (i === 0 && rect.top <= threshold) {
            newActiveIndex = 0;
          }
          break;
        }
      }
      
      // Fallback: Wenn noch kein Heading passiert wurde aber nah dran
      if (newActiveIndex === -1 && headings.length > 0) {
        const firstRect = headings[0].getBoundingClientRect();
        if (firstRect.top <= threshold + 50) {
          newActiveIndex = 0;
        }
      }
      
      // Nur aktualisieren wenn sich was geändert hat
      if (newActiveIndex !== currentActiveIndex && newActiveIndex >= 0) {
        currentActiveIndex = newActiveIndex;
        const activeLink = tocLinks[newActiveIndex];
        if (activeLink) {
          // Alle .active Klassen entfernen
          originalToc.querySelectorAll('.toc__menu li.active').forEach(li => {
            li.classList.remove('active');
          });
          // Nur das aktive Element markieren
          activeLink.parentElement.classList.add('active');
          
          // Sticky TOC aktualisieren (nur auf Mobile relevant)
          if (isMobile()) {
            updateCurrentHeading(activeLink.textContent.trim());
          }
        }
      }
    }
    
    // Scroll handler
    let customScrollTicking = false;
    window.addEventListener('scroll', function() {
      if (!customScrollTicking) {
        requestAnimationFrame(function() {
          updateActiveHeading();
          customScrollTicking = false;
        });
        customScrollTicking = true;
      }
    }, { passive: true });
    
    // Initial prüfen
    setTimeout(updateActiveHeading, 200);
  }
  
  // Custom ScrollSpy für ALLE Geräte (Desktop & Mobile)
  // Ersetzt Gumshoe für konsistentes Timing
  initCustomScrollSpy();
  
  // ==========================================================================
  // GUMSHOE EVENT LISTENER (Backup für Desktop)
  // ==========================================================================
  document.addEventListener('gumshoeActivate', function(event) {
    if (isMobile()) return;
    
    const link = event.detail && event.detail.link;
    if (link && originalToc.contains(link)) {
      updateCurrentHeading(link.textContent.trim());
    }
  }, false);
  
  // ==========================================================================
  // INITIALE ÜBERSCHRIFT (einmalig nach Gumshoe-Init)
  // ==========================================================================
  requestAnimationFrame(function() {
    // Kurz warten bis Gumshoe initialisiert hat
    setTimeout(function() {
      const activeLi = originalToc.querySelector('.toc__menu li.active');
      if (activeLi) {
        const link = activeLi.querySelector(':scope > a');
        if (link) {
          updateCurrentHeading(link.textContent.trim());
          return;
        }
      }
      // Fallback: Erster Link
      const firstLink = originalToc.querySelector('.toc__menu a');
      if (firstLink && !lastActiveText) {
        updateCurrentHeading(firstLink.textContent.trim());
      }
    }, 100);
  });
  
  // ==========================================================================
  // RESIZE HANDLER
  // ==========================================================================
  let resizeTimeout;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      cachedMastheadHeight = null; // Cache invalidieren
      updateStickyVisibility();
    }, 100);
  });

  // ==========================================================================
  // ORIGINAL TOC COLLAPSE FUNCTIONALITY (bestehender Code)
  // ==========================================================================
  {% if page.toc_collapse %}
  const tocToggle = document.getElementById('{{ toc_id }}-toggle');
  const tocContent = document.getElementById('{{ toc_id }}-content');
  
  if (tocToggle && tocContent) {
    const storageKey = '{{ toc_id }}-state';
    const prefersReducedMotion = window.matchMedia
      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
      : false;

    let resizeRaf = null;

    const updateMaxHeight = function() {
      if (tocToggle.getAttribute('aria-expanded') === 'true') {
        tocContent.style.maxHeight = tocContent.scrollHeight + 'px';
      }
    };

    const setExpanded = function(isExpanded, persist) {
      tocToggle.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
      tocContent.classList.toggle('is-collapsed', !isExpanded);
      if (isExpanded) {
        updateMaxHeight();
      } else {
        tocContent.style.maxHeight = '0px';
      }

      if (persist !== false) {
        try {
          localStorage.setItem(storageKey, isExpanded ? 'expanded' : 'collapsed');
        } catch (error) {
          // localStorage not available, ignore
        }
      }
    };

    let storedState;
    try {
      storedState = localStorage.getItem(storageKey);
    } catch (error) {
      storedState = null;
    }

    const startExpanded = storedState !== 'collapsed';
    setExpanded(startExpanded, false);

    if (prefersReducedMotion) {
      tocContent.style.transition = 'none';
    }

    tocToggle.addEventListener('click', function() {
      const isExpanded = tocToggle.getAttribute('aria-expanded') === 'true';
      setExpanded(!isExpanded);
    });

    window.addEventListener('resize', function() {
      if (resizeRaf) {
        cancelAnimationFrame(resizeRaf);
      }
      resizeRaf = requestAnimationFrame(updateMaxHeight);
    });
  }
  {% endif %}
});
</script>